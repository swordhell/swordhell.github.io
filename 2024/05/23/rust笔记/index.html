<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swordhell.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概述开始了解rust相关的编程。">
<meta property="og:type" content="article">
<meta property="og:title" content="rust笔记">
<meta property="og:url" content="https://swordhell.github.io/2024/05/23/rust%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Abel&#39;Blog">
<meta property="og:description" content="概述开始了解rust相关的编程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://swordhell.github.io/2024/05/23/rust%E7%AC%94%E8%AE%B0/rusticon.png">
<meta property="article:published_time" content="2024-05-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-24T07:25:29.305Z">
<meta property="article:author" content="Abel Sean">
<meta property="article:tag" content="rust">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://swordhell.github.io/2024/05/23/rust%E7%AC%94%E8%AE%B0/rusticon.png">

<link rel="canonical" href="https://swordhell.github.io/2024/05/23/rust%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>rust笔记 | Abel'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Abel'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我干了什么?究竟拿了时间换了什么?</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swordhell.github.io/2024/05/23/rust%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Abel Sean">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Abel'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rust笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-23 00:00:00" itemprop="dateCreated datePublished" datetime="2024-05-23T00:00:00+08:00">2024-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-24 15:25:29" itemprop="dateModified" datetime="2024-05-24T15:25:29+08:00">2024-05-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">1-基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1-%E5%9F%BA%E7%A1%80/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>开始了解rust相关的编程。</p>
<p><img src="/2024/05/23/rust%E7%AC%94%E8%AE%B0/rusticon.png" alt="rusticon"></p>
<span id="more"></span>
<h2 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h2><p>Rust是一种无运行时的强类型语言，它具有许多高级特性，如泛型和lambda等。Rust的内存安全机制比C++更完善，因为它采用了独特的所有权模型。Rust的语法与C++相似，但采用了类型后置的风格，即关键字后跟类型。Rust的变量声明使用let关键字，且变量一旦声明后其类型和值都不能改变，除非使用mut关键字显式地声明变量为可变的。</p>
<p>高性能</p>
<p>Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</p>
<p>可靠性</p>
<p>Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</p>
<p>生产力</p>
<p>Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具——包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</p>
<p>2024-05-23 我现在选择的是 1.78.0 版本。</p>
<h2 id="rust安装"><a href="#rust安装" class="headerlink" title="rust安装"></a>rust安装</h2><p>linux/mac机器上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>
<p>Rust 的升级非常频繁。如果您安装 Rustup 后已有一段时间，那么很可能您的 Rust 版本已经过时了。运行 <code>rustup update</code> 获取最新版本的 Rust。</p>
<p>vscode里面安装两个插件 <code>rust-analyzer</code>、<code>Native Debug</code>。</p>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/languages/rust">vscode-rust</a></p>
<h2 id="cargo-教程"><a href="#cargo-教程" class="headerlink" title="cargo 教程"></a>cargo 教程</h2><p>Cargo：Rust 的构建工具和包管理器</p>
<p>您在安装 Rustup 时，也会安装 Rust 构建工具和包管理器的最新稳定版，即 Cargo。Cargo 可以做很多事情：</p>
<ul>
<li>cargo build 可以构建项目</li>
<li>cargo run 可以运行项目</li>
<li>cargo test 可以测试项目</li>
<li>cargo doc 可以为项目构建文档</li>
<li>cargo publish 可以将库发布到 crates.io。</li>
</ul>
<p>要检查您是否安装了 Rust 和 Cargo，可以在终端中运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo --version</span><br><span class="line">cargo 1.75.0 (1d8b05cdd 2023-11-20)</span><br><span class="line"><span class="comment"># 创建了工程</span></span><br><span class="line">cargo new greeting </span><br></pre></td></tr></table></figure>
<h2 id="rust输出命令行"><a href="#rust输出命令行" class="headerlink" title="rust输出命令行"></a>rust输出命令行</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">12</span>; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a is &#123;&#125;&quot;</span>, a); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rustc runoob.rs</span></span><br><span class="line"><span class="comment">// ./runoob</span></span><br></pre></td></tr></table></figure>
<h2 id="Rust基本语法"><a href="#Rust基本语法" class="headerlink" title="Rust基本语法"></a>Rust基本语法</h2><p>如果要声明变量，需要使用 let 关键字。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>在语言层面尽量少的让变量的值可以改变。所以 a 的值不可变。但这不意味着 a 不是”变量”（英文中的 variable），官方文档称 a 这种变量为”不可变变量”。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="type">i32</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">123</span>;</span><br><span class="line">a = <span class="number">456</span>;</span><br></pre></td></tr></table></figure>
<p>重影（Shadowing）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The value of x is: 12</span></span><br></pre></td></tr></table></figure>
<h2 id="rust数据类型"><a href="#rust数据类型" class="headerlink" title="rust数据类型"></a>rust数据类型</h2><h3 id="整数型（Integer）"><a href="#整数型（Integer）" class="headerlink" title="整数型（Integer）"></a>整数型（Integer）</h3><div class="table-container">
<table>
<thead>
<tr>
<th>位长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128-bit</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>
</div>
<h3 id="浮点数型（Floating-Point）"><a href="#浮点数型（Floating-Point）" class="headerlink" title="浮点数型（Floating-Point）"></a>浮点数型（Floating-Point）</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = <span class="number">5</span> + <span class="number">10</span>; <span class="comment">// 加 </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">difference</span> = <span class="number">95.5</span> - <span class="number">4.3</span>; <span class="comment">// 减 </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">product</span> = <span class="number">4</span> * <span class="number">30</span>; <span class="comment">// 乘 </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotient</span> = <span class="number">56.7</span> / <span class="number">32.2</span>; <span class="comment">// 除 </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">remainder</span> = <span class="number">43</span> % <span class="number">5</span>; <span class="comment">// 求余</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：Rust 不支持 ++ 和 —，因为这两个运算符出现在变量的前后会影响代码可读性，减弱了开发者对变量改变的意识能力。</p>
<h2 id="rust注释"><a href="#rust注释" class="headerlink" title="rust注释"></a>rust注释</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">文档</span><br><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let x = add(1, 2);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="rust函数"><a href="#rust函数" class="headerlink" title="rust函数"></a>rust函数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, runoob!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个语法是错误的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = (<span class="keyword">let</span> <span class="variable">b</span> = <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x = 5, y = 4</span></span><br><span class="line"></span><br><span class="line">函数签到</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;five() 的值为: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">five</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rust条件句子"><a href="#rust条件句子" class="headerlink" title="rust条件句子"></a>rust条件句子</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">12</span>; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>; </span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0</span> &#123; </span><br><span class="line">        b = <span class="number">1</span>; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123; </span><br><span class="line">        b = -<span class="number">1</span>; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        b = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b is &#123;&#125;&quot;</span>, b); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三元条件</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3</span>; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> a &gt; <span class="number">0</span> &#123; <span class="number">1</span> &#125; <span class="keyword">else</span> &#123; -<span class="number">1</span> &#125;; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number 为 &#123;&#125;&quot;</span>, number); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rust循环"><a href="#rust循环" class="headerlink" title="rust循环"></a>rust循环</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">4</span> &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, number); </span><br><span class="line">        number += <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;EXIT&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]; </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>() &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;值为 : &#123;&#125;&quot;</span>, i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]; </span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a[&#123;&#125;] = &#123;&#125;&quot;</span>, i, a[i]); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = [<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">loop</span> &#123; </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ch</span> = s[i]; </span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">&#x27;O&#x27;</span> &#123; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;\&#x27;&#123;&#125;\&#x27;&quot;</span>, ch);</span><br><span class="line">        i += <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = [<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]; </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">location</span> = <span class="keyword">loop</span> &#123; </span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ch</span> = s[i];</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">&#x27;O&#x27;</span> &#123; </span><br><span class="line">            <span class="keyword">break</span> i; </span><br><span class="line">        &#125; </span><br><span class="line">        i += <span class="number">1</span>; </span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot; \&#x27;O\&#x27; 的索引为 &#123;&#125;&quot;</span>, location); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="rust迭代器"><a href="#rust迭代器" class="headerlink" title="rust迭代器"></a>rust迭代器</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>next()</td>
<td>返回迭代器中的下一个元素。</td>
<td>let mut iter = (1..5).into_iter(); while let Some(val) = iter.next() { println!(“{}”, val); }</td>
</tr>
<tr>
<td>size_hint()</td>
<td>返回迭代器中剩余元素数量的下界和上界。</td>
<td>let iter = (1..10).into_iter(); println!(“{:?}”, iter.size_hint());</td>
</tr>
<tr>
<td>count()</td>
<td>计算迭代器中的元素数量。</td>
<td>let count = (1..10).into_iter().count();</td>
</tr>
<tr>
<td>nth()</td>
<td>返回迭代器中第</td>
<td>n 个元素。    let third = (0..10).into_iter().nth(2);</td>
</tr>
<tr>
<td>last()</td>
<td>返回迭代器中的最后一个元素。</td>
<td>let last = (1..5).into_iter().last();</td>
</tr>
<tr>
<td>all()</td>
<td>如果迭代器中的所有元素都满足某个条件，返回</td>
<td>true。    let all_positive = (1..=5).into_iter().all(</td>
<td>x</td>
<td>x &gt; 0);</td>
</tr>
<tr>
<td>any()</td>
<td>如果迭代器中的至少一个元素满足某个条件，返回</td>
<td>true。    let any_negative = (1..5).into_iter().any(</td>
<td>x</td>
<td>x &lt; 0);</td>
</tr>
<tr>
<td>find()</td>
<td>返回迭代器中第一个满足某个条件的元素。</td>
<td>let first_even = (1..10).into_iter().find(</td>
<td>x</td>
<td>x % 2 == 0);</td>
</tr>
<tr>
<td>find_map()</td>
<td>对迭代器中的元素应用一个函数，返回第一个返回</td>
<td>Some 的结果。    let first_letter = “hello”.chars().find_map(</td>
<td>c</td>
<td>if c.is_alphabetic() { Some(c) } else { None });</td>
</tr>
<tr>
<td>map()</td>
<td>对迭代器中的每个元素应用一个函数。</td>
<td>let squares: Vec<i32> = (1..5).into_iter().map(</i32></td>
<td>x</td>
<td>x * x).collect();</td>
</tr>
<tr>
<td>filter()</td>
<td>保留迭代器中满足某个条件的元素。</td>
<td>let evens: Vec<i32> = (1..10).into_iter().filter(</i32></td>
<td>x</td>
<td>x % 2 == 0).collect();</td>
</tr>
<tr>
<td>filter_map()</td>
<td>对迭代器中的元素应用一个函数，如果函数返回</td>
<td>Some，则保留结果。    let chars: Vec<char> = “hello”.chars().filter_map(</char></td>
<td>c</td>
<td>if c.is_alphabetic() { Some(c.to_ascii_uppercase()) } else { None }).collect();</td>
</tr>
<tr>
<td>map_while()</td>
<td>对迭代器中的元素应用一个函数，直到函数返回</td>
<td>None。    let first_three = (1..).into_iter().map_while(</td>
<td>x</td>
<td>if x &lt;= 3 { Some(x) } else { None });</td>
</tr>
<tr>
<td>take_while()</td>
<td>从迭代器中取出满足某个条件的元素，直到不满足为止。</td>
<td>let first_five = (1..10).into_iter().take_while(</td>
<td>x</td>
<td>x &lt;= 5).collect::<Vec<_>&gt;()</Vec<_></td>
</tr>
<tr>
<td>skip_while()</td>
<td>跳过迭代器中满足某个条件的元素，直到不满足为止。</td>
<td>let odds: Vec<i32> = (1..10).into_iter().skip_while(</i32></td>
<td>x</td>
<td>x % 2 == 0).collect();</td>
</tr>
<tr>
<td>for_each()</td>
<td>对迭代器中的每个元素执行某种操作。</td>
<td>let mut counter = 0; (1..5).into_iter().for_each(</td>
<td>x</td>
<td>counter += x);</td>
</tr>
<tr>
<td>fold()</td>
<td>对迭代器中的元素进行折叠，使用一个累加器。</td>
<td>let sum: i32 = (1..5).into_iter().fold(0,</td>
<td>acc, x</td>
<td>acc + x);</td>
</tr>
<tr>
<td>try_fold()</td>
<td>对迭代器中的元素进行折叠，可能在遇到错误时提前返回。</td>
<td>let result: Result = (1..5).into_iter().try_fold(0,</td>
<td>acc, x</td>
<td>if x == 3 { Err(“Found the number 3”) } else { Ok(acc + x) });</td>
</tr>
<tr>
<td>scan()</td>
<td>对迭代器中的元素进行状态化的折叠。</td>
<td>let sum: Vec<i32> = (1..5).into_iter().scan(0,</i32></td>
<td>acc, x</td>
<td>{ <em>acc += x; Some(</em>acc) }).collect();</td>
</tr>
<tr>
<td>take()</td>
<td>从迭代器中取出最多</td>
<td>n 个元素。    let first<em>five = (1..10).into_iter().take(5).collect::&lt;Vec&lt;</em>&gt;&gt;()</td>
</tr>
<tr>
<td>skip()</td>
<td>跳过迭代器中的前</td>
<td>n 个元素。    let after<em>five = (1..10).into_iter().skip(5).collect::&lt;Vec&lt;</em>&gt;&gt;()</td>
</tr>
<tr>
<td>zip()</td>
<td>将两个迭代器中的元素打包成元组。</td>
<td>let zipped = (1..3).zip(&amp;[‘a’, ‘b’, ‘c’]).collect::<Vec<_>&gt;()</Vec<_></td>
</tr>
<tr>
<td>cycle()</td>
<td>重复迭代器中的元素，直到无穷。</td>
<td>let repeated = (1..3).into<em>iter().cycle().take(7).collect::&lt;Vec&lt;</em>&gt;&gt;()</td>
</tr>
<tr>
<td>chain()</td>
<td>连接多个迭代器。</td>
<td>let combined = (1..3).chain(4..6).collect::<Vec<_>&gt;()</Vec<_></td>
</tr>
<tr>
<td>rev()</td>
<td>反转迭代器中的元素顺序。</td>
<td>let reversed = (1..4).into<em>iter().rev().collect::&lt;Vec&lt;</em>&gt;&gt;()</td>
</tr>
<tr>
<td>enumerate()</td>
<td>为迭代器中的每个元素添加索引。</td>
<td>let enumerated = (1..4).into<em>iter().enumerate().collect::&lt;Vec&lt;</em>&gt;&gt;()</td>
</tr>
<tr>
<td>peeking_take_while()</td>
<td>取出满足条件的元素，同时保留迭代器的状态，可以继续取出后续元素。</td>
<td>let (first, rest) = (1..10).into_iter().peeking_take_while(</td>
<td>&amp;x</td>
<td>x &lt; 5);</td>
</tr>
<tr>
<td>step_by()</td>
<td>按照指定的步长返回迭代器中的元素。</td>
<td>let even<em>numbers = (0..10).into_iter().step_by(2).collect::&lt;Vec&lt;</em>&gt;&gt;()</td>
</tr>
<tr>
<td>fuse()</td>
<td>创建一个额外的迭代器，它在迭代器耗尽后仍然可以调用</td>
<td>next() 方法。    let mut iter = (1..5).into_iter().fuse(); while iter.next().is_some() {}</td>
</tr>
<tr>
<td>inspect()</td>
<td>在取出每个元素时执行一个闭包，但不改变元素。</td>
<td>let mut counter = 0; (1..5).into_iter().inspect(</td>
<td>x</td>
<td>println!(“Inspecting: {}”, x)).for_each(</td>
<td>x</td>
<td>println!(“Processing: {}”, x));</td>
</tr>
<tr>
<td>same_items()</td>
<td>比较两个迭代器是否产生相同的元素序列。</td>
<td>let equal = (1..5).into_iter().same_items((1..5).into_iter());</td>
</tr>
</tbody>
</table>
</div>
<p>在 Rust 中，迭代器（Iterator）是一个允许你逐个访问集合中每个元素的对象。迭代器提供了一种抽象的方法来处理集合，无需显式地管理索引或遍历逻辑。Rust 的迭代器具有惰性，即它们不会在你明确要求时执行任何操作。</p>
<p>迭代器是一个实现了 <code>Iterator</code> trait 的类型，这个 trait 定义了一些方法，其中最重要的是 <code>next</code> 方法，它返回迭代器中的下一个元素。</p>
<h3 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h3><p>Rust 中的集合类型（如数组、向量、哈希表等）都有方法创建迭代器。下面是一些示例：</p>
<h4 id="数组迭代器"><a href="#数组迭代器" class="headerlink" title="数组迭代器"></a>数组迭代器</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">iter</span> = arr.<span class="title function_ invoke__">iter</span>(); <span class="comment">// 创建一个数组的迭代器</span></span><br></pre></td></tr></table></figure>
<h4 id="向量迭代器"><a href="#向量迭代器" class="headerlink" title="向量迭代器"></a>向量迭代器</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">iter</span> = vec.<span class="title function_ invoke__">iter</span>(); <span class="comment">// 创建一个向量的迭代器</span></span><br></pre></td></tr></table></figure>
<h4 id="范围迭代器"><a href="#范围迭代器" class="headerlink" title="范围迭代器"></a>范围迭代器</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">iter</span> = <span class="number">1</span>..<span class="number">6</span>; <span class="comment">// 创建一个范围的迭代器，从1到5</span></span><br></pre></td></tr></table></figure>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>你可以使用 <code>for</code> 循环遍历迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vec.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用迭代器适配器"><a href="#常用迭代器适配器" class="headerlink" title="常用迭代器适配器"></a>常用迭代器适配器</h3><p>Rust 提供了一些强大的迭代器适配器，用于对迭代器进行变换、过滤和组合。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h4><p><code>map</code> 方法对每个元素应用一个闭包（函数）并返回一个新的迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">iter</span> = vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> iter &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val); <span class="comment">// 输出 2, 4, 6, 8, 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h4><p><code>filter</code> 方法使用一个闭包对每个元素进行过滤，并返回一个新的迭代器，只保留闭包返回 <code>true</code> 的元素：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">iter</span> = vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">filter</span>(|&amp;&amp;x| x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> iter &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, val); <span class="comment">// 输出 2, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a><code>collect</code></h4><p><code>collect</code> 方法将迭代器转换为集合类型（如向量、哈希表等）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">doubled</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x * <span class="number">2</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, doubled); <span class="comment">// 输出 [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h4 id="fold"><a href="#fold" class="headerlink" title="fold"></a><code>fold</code></h4><p><code>fold</code> 方法对迭代器中的每个元素应用一个累加器函数，生成一个单一的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">sum</span> = vec.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |acc, &amp;x| acc + x);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, sum); <span class="comment">// 输出 15</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>你也可以实现自己的迭代器，只需要实现 <code>Iterator</code> trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt;= <span class="number">5</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(count) = counter.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, count); <span class="comment">// 输出 1, 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>迭代器是 Rust 中处理集合和序列的强大工具，它们提供了一种灵活、简洁和高效的方式来处理数据。通过使用迭代器适配器，你可以链式调用多个操作，实现复杂的数据变换和过滤。</p>
<h2 id="rust闭包"><a href="#rust闭包" class="headerlink" title="rust闭包"></a>rust闭包</h2><p>当然！闭包（Closure）是Rust中的一个强大特性。它允许你捕获周围作用域中的变量，然后在以后调用它们。让我们通过几个简单的例子来解释闭包。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>闭包的基本语法如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">closure</span> = |参数| <span class="punctuation">-&gt;</span> 返回类型 &#123; 代码块 &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li><strong>一个简单的闭包：</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add_one</span> = |x: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_one</span>(<span class="number">5</span>)); <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure>
<p>这里，<code>add_one</code> 是一个闭包，它接收一个整数 <code>x</code>，返回 <code>x + 1</code>。</p>
<ol>
<li><strong>捕获外部变量：</strong></li>
</ol>
<p>闭包可以自动捕获它们所在环境中的变量：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_y</span> = |x: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_y</span>(<span class="number">3</span>)); <span class="comment">// 输出: 8</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，闭包 <code>add_y</code> 捕获了外部的变量 <code>y</code>。</p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>Rust 可以自动推断闭包的参数和返回类型，通常不需要显式声明：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">add_two</span> = |x| x + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">3</span>)); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包的三种类型"><a href="#闭包的三种类型" class="headerlink" title="闭包的三种类型"></a>闭包的三种类型</h3><p>根据捕获变量的方式，闭包分为三种类型：</p>
<ol>
<li><strong>按引用捕获</strong>：使用 <code>&amp;</code>，即借用。</li>
<li><strong>按值捕获</strong>：使用 <code>move</code>，即所有权转移。</li>
<li><strong>按可变引用捕获</strong>：使用 <code>&amp;mut</code>，即可变借用。</li>
</ol>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><ol>
<li><strong>按引用捕获：</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">print</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"><span class="title function_ invoke__">print</span>(); <span class="comment">// 输出: hello</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>按值捕获：</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">print</span> = <span class="keyword">move</span> || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"><span class="title function_ invoke__">print</span>(); <span class="comment">// 输出: hello</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>move</code> 关键字会将变量 <code>s</code> 的所有权移动到闭包内。</p>
<ol>
<li><strong>按可变引用捕获：</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">change</span> = || s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">change</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: hello, world</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，闭包 <code>change</code> 可变地借用了变量 <code>s</code>。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>闭包是Rust中非常灵活且强大的工具，允许你编写更简洁、更强大的代码。希望这些简单的例子能帮助你理解闭包的基本用法！</p>
<h2 id="rust所有权"><a href="#rust所有权" class="headerlink" title="rust所有权"></a>rust所有权</h2><p>在Rust中，所有权（Ownership）是一个核心概念，确保了内存安全性和无数据竞争。让我们通过一些简单的例子和解释来了解所有权。</p>
<h3 id="所有权的基本规则"><a href="#所有权的基本规则" class="headerlink" title="所有权的基本规则"></a>所有权的基本规则</h3><p>Rust 的所有权系统有三条基本规则：</p>
<ol>
<li><strong>每一个值都有一个所有者（Owner）。</strong></li>
<li><strong>每一个值同时只能有一个所有者。</strong></li>
<li><strong>当所有者超出作用域（Scope）时，值会被丢弃（Dropped）。</strong></li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="1-变量的所有权"><a href="#1-变量的所有权" class="headerlink" title="1. 变量的所有权"></a>1. 变量的所有权</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 拥有这个字符串</span></span><br><span class="line">    <span class="comment">// s 可以在这里使用</span></span><br><span class="line">&#125; <span class="comment">// 作用域结束，s 被丢弃</span></span><br></pre></td></tr></table></figure>
<p>当 <code>s</code> 超出作用域时，它的内存会被自动释放，这个过程被称为 <code>drop</code>。</p>
<h4 id="2-所有权转移（移动）"><a href="#2-所有权转移（移动）" class="headerlink" title="2. 所有权转移（移动）"></a>2. 所有权转移（移动）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1; <span class="comment">// s1 的所有权被移动到 s2</span></span><br><span class="line"><span class="comment">// s1 不再有效</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>s1</code> 的所有权被移动（Move）给了 <code>s2</code>，所以 <code>s1</code> 不能再被使用。</p>
<h4 id="3-克隆"><a href="#3-克隆" class="headerlink" title="3. 克隆"></a>3. 克隆</h4><p>如果需要在多个变量中使用同一个值，可以使用 <code>clone</code> 方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>(); <span class="comment">// s1 的值被克隆到 s2</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, s1, s2); <span class="comment">// 输出: hello, hello</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>clone</code> 方法，可以深度复制数据，从而 <code>s1</code> 和 <code>s2</code> 都有效。</p>
<h3 id="引用和借用"><a href="#引用和借用" class="headerlink" title="引用和借用"></a>引用和借用</h3><p>Rust 提供了引用（References）来实现借用（Borrowing），这允许你在不转移所有权的情况下使用值。</p>
<h4 id="1-不可变引用"><a href="#1-不可变引用" class="headerlink" title="1. 不可变引用"></a>1. 不可变引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1); <span class="comment">// 借用 s1</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len); <span class="comment">// s1 仍然有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>&amp;</code> 创建引用，函数 <code>calculate_length</code> 借用了 <code>s1</code> 而不获取其所有权。</p>
<h4 id="2-可变引用"><a href="#2-可变引用" class="headerlink" title="2. 可变引用"></a>2. 可变引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s); <span class="comment">// 可变借用 s</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 输出: hello, world</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>&amp;mut</code> 创建可变引用，可以修改借用的值。注意：同时只能有一个可变引用，防止数据竞争。</p>
<h3 id="悬垂引用（Dangling-References）"><a href="#悬垂引用（Dangling-References）" class="headerlink" title="悬垂引用（Dangling References）"></a>悬垂引用（Dangling References）</h3><p>Rust 不允许悬垂引用，确保引用永远是有效的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s <span class="comment">// 错误：返回对局部变量的引用</span></span><br><span class="line">&#125; <span class="comment">// s 被丢弃</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，返回对局部变量的引用会导致悬垂引用，Rust 会在编译时捕获这个错误。</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>Rust 的所有权系统通过所有权、借用和引用的规则，确保了内存安全性和无数据竞争。这些规则可能需要一些时间来习惯，但它们提供了强大的安全保证。希望这些示例和解释能帮助你理解Rust的所有权概念！</p>
<h2 id="rust切片"><a href="#rust切片" class="headerlink" title="rust切片"></a>rust切片</h2><p>在Rust中，slice是一种引用类型，用于表示一个连续的元素序列的子集。它不拥有数据，只是对数据的一种引用。slice可以帮助我们在不复制数据的情况下对数组或向量进行部分操作。以下是一些关于Rust slice的关键概念：</p>
<ol>
<li><p><strong>定义和语法</strong>：</p>
<ul>
<li>slice是通过一个引用和一个长度来定义的。</li>
<li>语法形式为：<code>&amp;[T]</code>或<code>&amp;mut [T]</code>，其中<code>T</code>是元素的类型。</li>
<li>不可变slice使用<code>&amp;</code>符号，可变slice使用<code>&amp;mut</code>符号。</li>
</ul>
</li>
<li><p><strong>创建和使用</strong>：</p>
<ul>
<li>你可以通过引用数组或向量的一部分来创建slice。</li>
<li>例如：<code>let slice = &amp;array[1..4];</code>表示创建一个引用，指向<code>array</code>的第2到第4个元素（不包括第4个元素）。</li>
</ul>
</li>
<li><p><strong>特性和功能</strong>：</p>
<ul>
<li>slice具有与数组类似的功能，例如可以使用索引访问元素。</li>
<li>slice的长度是固定的，不能动态改变。</li>
<li>slice可以用于函数参数，避免传递整个数组或向量，提升效率。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;arr[<span class="number">1</span>..<span class="number">4</span>]; <span class="comment">// 取得数组的第2到第4个元素的slice</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, slice); <span class="comment">// 输出：[2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用slice</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">elem</span> <span class="keyword">in</span> slice.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在这个示例中，<code>slice</code>是对数组<code>arr</code>的第2到第4个元素的引用，通过这种方式，你可以在不复制数据的情况下对这些元素进行操作。</p>
<p>slice在Rust中是一个非常强大的工具，能够让你更高效地处理数据，同时保证内存安全和性能。</p>
<p>这段代码的核心问题在于对<code>String</code>的可变引用和不可变引用之间的冲突。让我们逐行分析代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;runoob&quot;</span>);  <span class="comment">// 创建一个可变的String变量s</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">3</span>];                <span class="comment">// 创建一个指向s的前3个字符的不可变slice</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;yes!&quot;</span>);                  <span class="comment">// 试图向s追加字符串 &quot;yes!&quot;，导致错误</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;slice = &#123;&#125;&quot;</span>, slice);       <span class="comment">// 打印slice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>创建<code>String</code>变量<code>mut s</code></strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;runoob&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里创建了一个可变的<code>String</code>变量<code>s</code>，并初始化为”runoob”。</p>
</li>
<li><p><strong>创建不可变的slice</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>这里创建了一个不可变的slice，引用<code>s</code>的前3个字符（即”run”）。这个slice是不可变的，并且它引用的是<code>s</code>的部分数据。</p>
</li>
<li><p><strong>尝试修改<code>String</code></strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;yes!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码试图向<code>s</code>追加字符串”yes!”。然而，Rust的借用规则规定，在存在一个不可变引用时，不能创建可变引用或修改原数据。这是为了防止数据竞争和保持内存安全。因此，这行代码会导致编译错误。</p>
</li>
<li><p><strong>打印slice</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;slice = &#123;&#125;&quot;</span>, slice);</span><br></pre></td></tr></table></figure>
<p>这行代码会打印<code>slice</code>的内容（即”run”），但由于前一行的错误，程序在编译时就会失败，所以这行代码实际上不会执行。</p>
</li>
</ol>
<h3 id="错误的原因"><a href="#错误的原因" class="headerlink" title="错误的原因"></a>错误的原因</h3><p>在Rust中，借用规则如下：</p>
<ul>
<li>一个变量可以有任意多个不可变引用（<code>&amp;T</code>）。</li>
<li>一个变量在任何时候只能有一个可变引用（<code>&amp;mut T</code>）。</li>
<li>如果存在不可变引用，就不能创建可变引用，反之亦然。</li>
</ul>
<p>在这段代码中，<code>slice</code>是对<code>s</code>的不可变引用，而随后试图对<code>s</code>进行修改（通过<code>push_str</code>方法），这是不允许的。因此，编译器会报错。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>为了避免这个错误，可以在修改<code>s</code>之前不持有任何不可变引用。下面是修改后的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;runoob&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">3</span>];          <span class="comment">// 创建不可变的slice</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;slice = &#123;&#125;&quot;</span>, slice); <span class="comment">// 使用slice</span></span><br><span class="line">    &#125; <span class="comment">// 这里，slice的作用域结束，不再引用s</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;yes!&quot;</span>);                <span class="comment">// 现在可以安全地修改s</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s = &#123;&#125;&quot;</span>, s);             <span class="comment">// 打印修改后的s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本中，<code>slice</code>的作用域限制在一个新的块中，当块结束时，<code>slice</code>不再引用<code>s</code>。这样，在后面可以安全地修改<code>s</code>。</p>
<h2 id="rust结构体"><a href="#rust结构体" class="headerlink" title="rust结构体"></a>rust结构体</h2><p>在Rust中，结构体（struct）是一种自定义数据类型，用于将相关的数据组合在一起。结构体在Rust中有三种主要形式：经典结构体（C-like struct）、元组结构体（tuple struct）和单元结构体（unit-like struct）。下面详细介绍每种结构体并给出相应的示例代码。</p>
<h3 id="1-经典结构体（C-like-Struct）"><a href="#1-经典结构体（C-like-Struct）" class="headerlink" title="1. 经典结构体（C-like Struct）"></a>1. 经典结构体（C-like Struct）</h3><p>经典结构体类似于其他编程语言中的结构体或类，具有命名字段。</p>
<h4 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user1&quot;</span>),</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user1@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Username: &#123;&#125;&quot;</span>, user1.username);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Email: &#123;&#125;&quot;</span>, user1.email);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Sign in count: &#123;&#125;&quot;</span>, user1.sign_in_count);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Active: &#123;&#125;&quot;</span>, user1.active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-元组结构体（Tuple-Struct）"><a href="#2-元组结构体（Tuple-Struct）" class="headerlink" title="2. 元组结构体（Tuple Struct）"></a>2. 元组结构体（Tuple Struct）</h3><p>元组结构体是没有命名字段的结构体，使用方式类似于元组。</p>
<h4 id="定义和使用-1"><a href="#定义和使用-1" class="headerlink" title="定义和使用"></a>定义和使用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Black: (&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, black.<span class="number">0</span>, black.<span class="number">1</span>, black.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Origin: (&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, origin.<span class="number">0</span>, origin.<span class="number">1</span>, origin.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-单元结构体（Unit-like-Struct）"><a href="#3-单元结构体（Unit-like-Struct）" class="headerlink" title="3. 单元结构体（Unit-like Struct）"></a>3. 单元结构体（Unit-like Struct）</h3><p>单元结构体没有任何字段，通常用于实现某种特征或标记。</p>
<h4 id="定义和使用-2"><a href="#定义和使用-2" class="headerlink" title="定义和使用"></a>定义和使用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体的方法"><a href="#结构体的方法" class="headerlink" title="结构体的方法"></a>结构体的方法</h3><p>你可以为结构体定义方法和关联函数，使用<code>impl</code>块来实现。</p>
<h4 id="方法和关联函数示例"><a href="#方法和关联函数示例" class="headerlink" title="方法和关联函数示例"></a>方法和关联函数示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数，不需要self参数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法，需要self参数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123; width: <span class="number">10</span>, height: <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect3</span> = Rectangle &#123; width: <span class="number">60</span>, height: <span class="number">45</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect2? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect3? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sq</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The area of the square is &#123;&#125; square pixels.&quot;</span>, sq.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体的所有权"><a href="#结构体的所有权" class="headerlink" title="结构体的所有权"></a>结构体的所有权</h3><p>结构体中的字段可以拥有数据的所有权，也可以引用其他数据。使用引用时，需要考虑生命周期。</p>
<h4 id="生命周期示例"><a href="#生命周期示例" class="headerlink" title="生命周期示例"></a>生命周期示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    username: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">email</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;user1@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user</span> = User &#123;</span><br><span class="line">        username: &amp;name,</span><br><span class="line">        email: &amp;email,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Username: &#123;&#125;&quot;</span>, user.username);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Email: &#123;&#125;&quot;</span>, user.email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust的结构体功能强大且灵活，结合其所有权和借用系统，可以帮助开发者编写安全且高效的代码。</p>
<h2 id="rust枚举类"><a href="#rust枚举类" class="headerlink" title="rust枚举类"></a>rust枚举类</h2><p>在Rust中，枚举（enum）是一种定义可能值的集合的数据类型。枚举允许你将一个值与一组预定义的标签（变体）之一关联起来。每个变体可以携带不同类型和数量的数据。枚举在处理有限集合的可能值时特别有用。</p>
<h3 id="定义和使用枚举"><a href="#定义和使用枚举" class="headerlink" title="定义和使用枚举"></a>定义和使用枚举</h3><h4 id="基本枚举"><a href="#基本枚举" class="headerlink" title="基本枚举"></a>基本枚举</h4><p>这是一个简单的枚举示例，没有附加数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">go</span> = Direction::Up;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> go &#123;</span><br><span class="line">        Direction::Up =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Going up!&quot;</span>),</span><br><span class="line">        Direction::Down =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Going down!&quot;</span>),</span><br><span class="line">        Direction::Left =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Going left!&quot;</span>),</span><br><span class="line">        Direction::Right =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Going right!&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带数据的枚举"><a href="#带数据的枚举" class="headerlink" title="带数据的枚举"></a>带数据的枚举</h4><p>枚举的每个变体可以携带不同类型和数量的数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">messages</span> = [</span><br><span class="line">        Message::Quit,</span><br><span class="line">        Message::Move &#123; x: <span class="number">10</span>, y: <span class="number">20</span> &#125;,</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>)),</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">message</span> <span class="keyword">in</span> &amp;messages &#123;</span><br><span class="line">        <span class="keyword">match</span> message &#123;</span><br><span class="line">            Message::Quit =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Quit message&quot;</span>),</span><br><span class="line">            Message::Move &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Move to (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">            Message::<span class="title function_ invoke__">Write</span>(text) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Write message: &#123;&#125;&quot;</span>, text),</span><br><span class="line">            Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Change color to (r: &#123;&#125;, g: &#123;&#125;, b: &#123;&#125;)&quot;</span>, r, g, b),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Option枚举"><a href="#使用Option枚举" class="headerlink" title="使用Option枚举"></a>使用<code>Option</code>枚举</h3><p>Rust标准库定义了一个非常常用的枚举类型<code>Option</code>，用于处理可能为空的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> some_number &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We have a value: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We have no value&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> absent_number &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We have a value: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We have no value&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Result枚举"><a href="#使用Result枚举" class="headerlink" title="使用Result枚举"></a>使用<code>Result</code>枚举</h3><p>Rust标准库还定义了一个常用的枚举类型<code>Result</code>，用于处理可能的错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(dividend: <span class="type">i32</span>, divisor: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Cannot divide by zero&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(dividend / divisor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(<span class="number">10</span>, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法和枚举"><a href="#方法和枚举" class="headerlink" title="方法和枚举"></a>方法和枚举</h3><p>你可以为枚举定义方法，类似于为结构体定义方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Message::Quit =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Quit message&quot;</span>),</span><br><span class="line">            Message::Move &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Move to (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">            Message::<span class="title function_ invoke__">Write</span>(text) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Write message: &#123;&#125;&quot;</span>, text),</span><br><span class="line">            Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Change color to (r: &#123;&#125;, g: &#123;&#125;, b: &#123;&#125;)&quot;</span>, r, g, b),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>));</span><br><span class="line">    m.<span class="title function_ invoke__">call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Rust中的枚举非常强大，允许定义复杂的类型并对其进行模式匹配。这使得代码更加简洁和易读，同时还能确保在编译时就捕获到许多潜在的错误。</p>
<h2 id="rust组织管理"><a href="#rust组织管理" class="headerlink" title="rust组织管理"></a>rust组织管理</h2><p>在Rust中，程序的组织方式主要涉及三个概念：crate、package和module。理解这些概念及其相互关系，有助于编写清晰、可维护的Rust代码。以下是对这三个概念的详细解释：</p>
<h3 id="1-Crate"><a href="#1-Crate" class="headerlink" title="1. Crate"></a>1. Crate</h3><p><strong>Crate</strong>是Rust中的一个最小的编译单元。每个Rust项目都是一个crate，有两种类型的crate：</p>
<ul>
<li><strong>Binary Crate</strong>：生成一个可执行文件。每个binary crate都有一个<code>main</code>函数作为入口点。通常，Rust项目的根目录下有一个<code>src/main.rs</code>文件，它定义了一个binary crate。</li>
<li><strong>Library Crate</strong>：生成一个库，可以被其他crate使用。通常，Rust项目的根目录下有一个<code>src/lib.rs</code>文件，它定义了一个library crate。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>创建一个binary crate的项目结构：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_project</span><br><span class="line">│</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></p>
<p>创建一个library crate的项目结构：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_library</span><br><span class="line">│</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── lib.rs</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Package"><a href="#2-Package" class="headerlink" title="2. Package"></a>2. Package</h3><p><strong>Package</strong>是包含一个或多个crate的文件夹，提供一个<code>Cargo.toml</code>文件来描述这些crate以及它们之间的依赖关系。一个package可以包含以下内容：</p>
<ul>
<li>至多一个library crate。</li>
<li>零个或多个binary crate。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><p>一个包含一个library crate和一个binary crate的package结构：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_package</span><br><span class="line">│</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── lib.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></p>
<h3 id="3-Module"><a href="#3-Module" class="headerlink" title="3. Module"></a>3. Module</h3><p><strong>Module</strong>是用于在crate内部组织代码的工具。通过模块，可以将代码分割成多个逻辑单元，增加代码的可读性和可维护性。模块可以嵌套，并且可以在文件内或跨文件进行定义。</p>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> network; <span class="comment">// 声明一个名为 network 的模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/network.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">connect</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;network::connect&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">mod</span> network; <span class="comment">// 声明一个名为 network 的模块</span></span><br><span class="line"><span class="keyword">use</span> network::connect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">connect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义和使用模块"><a href="#定义和使用模块" class="headerlink" title="定义和使用模块"></a>定义和使用模块</h4><p>你可以在一个文件中定义多个模块，也可以跨多个文件定义模块。</p>
<p><strong>在一个文件中定义模块：</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> network &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">connect</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;network::connect&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> server &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">start</span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;server::start&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    network::<span class="title function_ invoke__">connect</span>();</span><br><span class="line">    network::server::<span class="title function_ invoke__">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>跨多个文件定义模块：</strong></p>
<p>假设有以下项目结构：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_project</span><br><span class="line">│</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── main.rs</span><br><span class="line">    ├── network</span><br><span class="line">    │   ├── mod.rs</span><br><span class="line">    │   └── server.rs</span><br><span class="line">    └── client.rs</span><br></pre></td></tr></table></figure></p>
<p><code>src/main.rs</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> network;</span><br><span class="line"><span class="keyword">mod</span> client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    network::<span class="title function_ invoke__">connect</span>();</span><br><span class="line">    network::server::<span class="title function_ invoke__">start</span>();</span><br><span class="line">    client::<span class="title function_ invoke__">connect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>src/network/mod.rs</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">connect</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;network::connect&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> server;</span><br></pre></td></tr></table></figure></p>
<p><code>src/network/server.rs</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">start</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;server::start&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>src/client.rs</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">connect</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;client::connect&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Crate</strong>：最小的编译单元，包含binary crate和library crate。</li>
<li><strong>Package</strong>：包含一个或多个crate，使用<code>Cargo.toml</code>文件管理。</li>
<li><strong>Module</strong>：用于在crate内部组织代码，可以嵌套和跨文件。</li>
</ul>
<p>通过crate、package和module的组合，Rust提供了一种灵活且强大的方式来组织和管理代码，使得代码更易于维护和扩展。<br>在Rust中，<strong>Package</strong> 是一个包含一个或多个 crate 的文件夹，并且包含一个 <code>Cargo.toml</code> 文件来管理这些 crate 及其依赖项。可以把 Package 理解为一个独立的工作单元，它提供了一组功能，或者一个应用程序。下面是对 Package 及其相关概念的详细解释：</p>
<h3 id="Package-的核心概念"><a href="#Package-的核心概念" class="headerlink" title="Package 的核心概念"></a>Package 的核心概念</h3><ol>
<li><p><strong>Cargo.toml 文件</strong>：每个 Package 都有一个 <code>Cargo.toml</code> 文件。这个文件包含了 Package 的元数据，比如名称、版本、依赖项等。</p>
</li>
<li><p><strong>Crate</strong>：一个 Package 至少包含一个 Crate（可以是 Library Crate 或 Binary Crate），但可以包含多个 Crate。一个 Package 最多包含一个 Library Crate，但可以包含多个 Binary Crate。</p>
</li>
<li><p><strong>src 目录</strong>：通常 Package 会有一个 <code>src</code> 目录，其中包含源代码文件。</p>
</li>
</ol>
<h3 id="创建-Package"><a href="#创建-Package" class="headerlink" title="创建 Package"></a>创建 Package</h3><p>使用 Cargo 工具来创建一个新的 Package。例如，创建一个名为 <code>my_package</code> 的 Package：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new my_package</span><br></pre></td></tr></table></figure>
<p>这个命令会生成以下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_package</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>
<p>这个 Package 包含一个 Binary Crate，因为 <code>src</code> 目录下有一个 <code>main.rs</code> 文件。</p>
<h3 id="Cargo-toml-文件"><a href="#Cargo-toml-文件" class="headerlink" title="Cargo.toml 文件"></a>Cargo.toml 文件</h3><p><code>Cargo.toml</code> 文件是 Package 的配置文件，它包含了 Package 的元数据和依赖项信息。以下是一个简单的 <code>Cargo.toml</code> 文件示例：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;my_package&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Author Name &lt;author@example.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;1.0&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>[package]</strong>：包含 Package 的基本信息，如名称、版本、作者和编译版本。</li>
<li><strong>[dependencies]</strong>：列出 Package 所依赖的库。在这个示例中，<code>serde</code> 是一个依赖项。</li>
</ul>
<h3 id="包含多个-Crate"><a href="#包含多个-Crate" class="headerlink" title="包含多个 Crate"></a>包含多个 Crate</h3><p>一个 Package 可以包含一个 Library Crate 和多个 Binary Crate。可以通过创建多个文件来实现。以下是一个包含一个 Library Crate 和两个 Binary Crate 的 Package 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_package</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── lib.rs        // Library Crate</span><br><span class="line">    ├── main.rs       // Binary Crate 1</span><br><span class="line">    └── bin</span><br><span class="line">        └── another_binary.rs  // Binary Crate 2</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>lib.rs</strong>：定义了一个 Library Crate。</li>
<li><strong>main.rs</strong>：定义了第一个 Binary Crate。</li>
<li><strong>bin/another_binary.rs</strong>：定义了第二个 Binary Crate。</li>
</ul>
<h3 id="使用模块组织代码"><a href="#使用模块组织代码" class="headerlink" title="使用模块组织代码"></a>使用模块组织代码</h3><p>你可以使用模块在一个 Package 内组织代码。例如：</p>
<p><code>src/lib.rs</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> network;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> client;</span><br></pre></td></tr></table></figure></p>
<p><code>src/network/mod.rs</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">connect</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;network::connect&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> server;</span><br></pre></td></tr></table></figure></p>
<p><code>src/network/server.rs</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">start</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;server::start&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>src/client.rs</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">connect</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;client::connect&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Package</strong> 是一个包含一个或多个 Crate 的独立工作单元，由一个 <code>Cargo.toml</code> 文件管理。</li>
<li>每个 Package 至少包含一个 Crate，可以是 Library Crate 或 Binary Crate。</li>
<li><code>Cargo.toml</code> 文件定义了 Package 的元数据和依赖项。</li>
<li>通过模块（mod）在 Crate 内组织代码，使得代码结构更清晰、更易维护。</li>
</ul>
<p>这种组织方式使得 Rust 项目可以很容易地扩展和维护，促进代码的重用和模块化。</p>
<h2 id="rust错误处理"><a href="#rust错误处理" class="headerlink" title="rust错误处理"></a>rust错误处理</h2><p>Rust 中的错误处理主要通过两种类型实现：<code>Result</code> 和 <code>Option</code>。其中，<code>Result</code> 用于处理可能失败的操作，而 <code>Option</code> 用于处理可能不存在的值。Rust 的错误处理强调显式处理错误，避免了许多其他编程语言中常见的隐式错误传播问题。</p>
<h3 id="1-使用-Result-处理错误"><a href="#1-使用-Result-处理错误" class="headerlink" title="1. 使用 Result 处理错误"></a>1. 使用 <code>Result</code> 处理错误</h3><p><code>Result</code> 枚举用于表示可能的成功或失败结果。它有两个变体：</p>
<ul>
<li><code>Ok(T)</code>：表示操作成功，包含成功的值。</li>
<li><code>Err(E)</code>：表示操作失败，包含错误的信息。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>假设我们有一个函数用来读取文件内容：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file_content</span>(path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file</span> = File::<span class="title function_ invoke__">open</span>(path)?; <span class="comment">// `?` 运算符自动传播错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">content</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> content)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">read_file_content</span>(<span class="string">&quot;example.txt&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(content) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;File content: &#123;&#125;&quot;</span>, content),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error reading file: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="? 运算符"></a><code>?</code> 运算符</h4><p><code>?</code> 运算符用于简化错误传播。如果函数返回 <code>Result</code> 类型，<code>?</code> 运算符可以在遇到 <code>Err</code> 时返回错误，而在遇到 <code>Ok</code> 时继续执行。</p>
<h3 id="2-使用-Option-处理值的存在性"><a href="#2-使用-Option-处理值的存在性" class="headerlink" title="2. 使用 Option 处理值的存在性"></a>2. 使用 <code>Option</code> 处理值的存在性</h3><p><code>Option</code> 枚举用于表示可能存在或不存在的值。它有两个变体：</p>
<ul>
<li><code>Some(T)</code>：表示值存在，包含值。</li>
<li><code>None</code>：表示值不存在。</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>假设我们有一个函数用来从数组中获取元素：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_element</span>(arr: &amp;[<span class="type">i32</span>], index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> index &lt; arr.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(arr[index])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">get_element</span>(&amp;arr, <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Element at index 2: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No element at index 2&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">get_element</span>(&amp;arr, <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Element at index 10: &#123;&#125;&quot;</span>, value),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No element at index 10&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-自定义错误类型"><a href="#3-自定义错误类型" class="headerlink" title="3. 自定义错误类型"></a>3. 自定义错误类型</h3><p>你可以定义自己的错误类型来处理特定场景下的错误。</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">IoError</span>(io::Error),</span><br><span class="line">    ParseError,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            MyError::<span class="title function_ invoke__">IoError</span>(e) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;IO error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">            MyError::ParseError =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse error&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        MyError::<span class="title function_ invoke__">IoError</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file_and_parse_number</span>(path: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, MyError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">content</span> = <span class="title function_ invoke__">read_file_content</span>(path)?; <span class="comment">// 使用先前定义的 read_file_content 函数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span>: <span class="type">i32</span> = content.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">map_err</span>(|_| MyError::ParseError)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">read_file_and_parse_number</span>(<span class="string">&quot;number.txt&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(number) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Parsed number: &#123;&#125;&quot;</span>, number),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-错误传播"><a href="#4-错误传播" class="headerlink" title="4. 错误传播"></a>4. 错误传播</h3><p>Rust 的错误传播通过 <code>?</code> 运算符进行，当函数返回类型是 <code>Result</code> 或 <code>Option</code> 时，<code>?</code> 可以在遇到错误时自动返回。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Result</strong>：用于处理可能失败的操作，具有 <code>Ok(T)</code> 和 <code>Err(E)</code> 变体。</li>
<li><strong>Option</strong>：用于处理可能不存在的值，具有 <code>Some(T)</code> 和 <code>None</code> 变体。</li>
<li><strong>? 运算符</strong>：用于简化错误传播。</li>
<li><strong>自定义错误类型</strong>：可以通过实现 <code>std::fmt::Display</code> 和 <code>std::error::Error</code> 特征来自定义错误类型。</li>
<li><strong>错误传播</strong>：通过 <code>?</code> 运算符自动传播错误。</li>
</ul>
<p>Rust 强调显式错误处理，通过类型系统和模式匹配提供了一种安全且高效的错误处理方式。</p>
<h2 id="rust中的panic"><a href="#rust中的panic" class="headerlink" title="rust中的panic"></a>rust中的panic</h2><p>在Rust中，<code>panic!</code> 宏用于处理不可恢复的错误。当程序遇到致命错误时，<code>panic!</code> 宏会终止当前线程的执行，并开始展开（unwind）过程以清理线程中的资源，或直接中止（abort）程序。下面详细介绍 <code>panic!</code> 的机制和处理方式。</p>
<h3 id="1-panic-的基本用法"><a href="#1-panic-的基本用法" class="headerlink" title="1. panic! 的基本用法"></a>1. <code>panic!</code> 的基本用法</h3><p><code>panic!</code> 宏通常用于程序遇到无法继续执行的情况，如数组越界、非法状态等。以下是一个简单的示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v[<span class="number">99</span>]); <span class="comment">// 访问越界元素，触发 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会因为试图访问不存在的元素而触发 <code>panic!</code>。<code>panic!</code> 会打印一个错误信息，并终止程序。</p>
<h3 id="2-捕获-panic：使用-std-panic-catch-unwind"><a href="#2-捕获-panic：使用-std-panic-catch-unwind" class="headerlink" title="2. 捕获 panic：使用 std::panic::catch_unwind"></a>2. 捕获 <code>panic</code>：使用 <code>std::panic::catch_unwind</code></h3><p>在某些情况下，你可能希望捕获 <code>panic</code> 而不是让程序崩溃。这可以使用 <code>std::panic::catch_unwind</code> 实现，它允许你捕获 <code>panic</code> 并继续执行。</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::panic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = panic::<span class="title function_ invoke__">catch_unwind</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;About to panic!&quot;</span>);</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;This is a panic!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No panic occurred.&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Caught a panic: &#123;:?&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Program continues to run.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>catch_unwind</code> 捕获了 <code>panic</code>，并使程序能够继续运行。</p>
<h3 id="3-恢复（unwind）与终止（abort）"><a href="#3-恢复（unwind）与终止（abort）" class="headerlink" title="3. 恢复（unwind）与终止（abort）"></a>3. 恢复（unwind）与终止（abort）</h3><p>Rust 在遇到 <code>panic</code> 时有两种处理策略：</p>
<ol>
<li><p><strong>展开（unwind）</strong>：默认情况下，Rust 会展开栈，清理每一层函数的资源。这种方式允许你在某些情况下捕获并恢复 <code>panic</code>，但会增加一些运行时开销。</p>
</li>
<li><p><strong>中止（abort）</strong>：你可以配置Rust在遇到<code>panic</code>时直接终止程序，而不进行栈展开。这种方式更高效，但不允许你捕获和恢复<code>panic</code>。</p>
</li>
</ol>
<p>你可以在 <code>Cargo.toml</code> 中配置 <code>panic</code> 策略：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-自定义-panic-行为：std-panic-set-hook"><a href="#4-自定义-panic-行为：std-panic-set-hook" class="headerlink" title="4. 自定义 panic 行为：std::panic::set_hook"></a>4. 自定义 <code>panic</code> 行为：<code>std::panic::set_hook</code></h3><p>你可以自定义 <code>panic</code> 时的行为，比如记录日志或打印自定义消息。这可以通过 <code>std::panic::set_hook</code> 实现。</p>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::panic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    panic::<span class="title function_ invoke__">set_hook</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|info| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Custom panic hook: &#123;:?&#125;&quot;</span>, info);</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;This is a custom panic!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>set_hook</code> 设置了一个自定义的 <code>panic</code> 钩子函数，当 <code>panic</code> 发生时，会执行这个函数。</p>
<h3 id="5-避免-panic"><a href="#5-避免-panic" class="headerlink" title="5. 避免 panic"></a>5. 避免 <code>panic</code></h3><p>尽量在代码中避免使用 <code>panic!</code>，特别是在库代码中。可以通过返回 <code>Result</code> 或 <code>Option</code> 类型来处理可能的错误，从而让调用者决定如何处理错误。</p>
<h4 id="示例：使用-Result-代替-panic"><a href="#示例：使用-Result-代替-panic" class="headerlink" title="示例：使用 Result 代替 panic"></a>示例：使用 <code>Result</code> 代替 <code>panic</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">divide</span>(a: <span class="type">f64</span>, b: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">f64</span>, <span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Division by zero&quot;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(a / b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(<span class="number">4.0</span>, <span class="number">2.0</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">divide</span>(<span class="number">4.0</span>, <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(result) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, result),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(err) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, err),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>divide</code> 函数返回一个 <code>Result</code> 类型，而不是在遇到除零错误时调用 <code>panic!</code>。</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>panic!</code>：用于处理不可恢复的错误，会终止当前线程的执行。</li>
<li>捕获 <code>panic</code>：使用 <code>std::panic::catch_unwind</code> 可以捕获 <code>panic</code> 并继续执行。</li>
<li>恢复与终止：Rust 默认使用展开（unwind）策略，你可以配置为中止（abort）策略。</li>
<li>自定义 <code>panic</code> 行为：使用 <code>std::panic::set_hook</code> 可以自定义 <code>panic</code> 时的行为。</li>
<li>避免 <code>panic</code>：尽量使用 <code>Result</code> 或 <code>Option</code> 处理可能的错误，避免在库代码中使用 <code>panic!</code>。</li>
</ul>
<p>通过这些机制，Rust 提供了灵活且安全的错误处理方式，使得程序更健壮、更易于维护。</p>
<h2 id="rust泛型特征"><a href="#rust泛型特征" class="headerlink" title="rust泛型特征"></a>rust泛型特征</h2><h3 id="Rust-中的泛型（Generics）"><a href="#Rust-中的泛型（Generics）" class="headerlink" title="Rust 中的泛型（Generics）"></a>Rust 中的泛型（Generics）</h3><p><strong>泛型</strong>允许你编写适用于多种数据类型的代码，而无需重复相同的逻辑。它可以用于函数、结构体、枚举和方法。泛型通过类型参数来实现，这些类型参数通常以尖括号包围。</p>
<h4 id="示例：泛型函数"><a href="#示例：泛型函数" class="headerlink" title="示例：泛型函数"></a>示例：泛型函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">chars</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Largest number: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">largest</span>(&amp;numbers));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Largest char: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">largest</span>(&amp;chars));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>largest</code> 函数使用泛型 <code>T</code> 来表示它可以处理任何实现了 <code>PartialOrd</code> 特征的类型。</p>
<h4 id="示例：泛型结构体"><a href="#示例：泛型结构体" class="headerlink" title="示例：泛型结构体"></a>示例：泛型结构体</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer_point</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float_point</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Integer Point: (&#123;&#125;, &#123;&#125;)&quot;</span>, integer_point.x, integer_point.y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Float Point: (&#123;&#125;, &#123;&#125;)&quot;</span>, float_point.x, float_point.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>Point</code> 结构体使用泛型 <code>T</code> 来表示 <code>x</code> 和 <code>y</code> 可以是任何类型。</p>
<h3 id="Rust-中的特征（Traits）"><a href="#Rust-中的特征（Traits）" class="headerlink" title="Rust 中的特征（Traits）"></a>Rust 中的特征（Traits）</h3><p><strong>特征</strong>定义了一组方法签名，任何实现该特征的类型都必须实现这些方法。特征类似于其他语言中的接口。</p>
<h4 id="示例：定义和实现特征"><a href="#示例：定义和实现特征" class="headerlink" title="示例：定义和实现特征"></a>示例：定义和实现特征</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Printable</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Point(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    p.<span class="title function_ invoke__">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>Printable</code> 特征定义了一个 <code>print</code> 方法。<code>Point</code> 结构体实现了这个特征，并提供了 <code>print</code> 方法的具体实现。</p>
<h4 id="示例：带有特征约束的泛型函数"><a href="#示例：带有特征约束的泛型函数" class="headerlink" title="示例：带有特征约束的泛型函数"></a>示例：带有特征约束的泛型函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_item</span>&lt;T: Printable&gt;(item: T) &#123;</span><br><span class="line">    item.<span class="title function_ invoke__">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Printable</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Point(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="title function_ invoke__">print_item</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>print_item</code> 函数使用泛型 <code>T</code> 并要求 <code>T</code> 实现 <code>Printable</code> 特征。</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>泛型</strong>：使代码适用于多种数据类型，通过类型参数表示。<ul>
<li>用法：函数、结构体、枚举和方法。</li>
</ul>
</li>
<li><strong>特征</strong>：定义共享行为，类似于接口。<ul>
<li>用法：定义方法签名，并由具体类型实现。</li>
</ul>
</li>
</ul>
<p>通过这两个概念，Rust 提供了强大的抽象能力，使得代码更加灵活和可重用。</p>
<h2 id="rust生命周期"><a href="#rust生命周期" class="headerlink" title="rust生命周期"></a>rust生命周期</h2><p>在 Rust 中，<strong>生命周期</strong>（lifetime）是一个重要的概念，用于管理引用的有效范围，确保引用在使用时是有效的。Rust 的生命周期系统是其内存安全的重要保证之一，防止悬垂引用和数据竞争问题。下面是对生命周期的简要说明，以及它与其他语言的不同之处。</p>
<h3 id="Rust-中的生命周期"><a href="#Rust-中的生命周期" class="headerlink" title="Rust 中的生命周期"></a>Rust 中的生命周期</h3><ol>
<li><p><strong>基本概念</strong>：</p>
<ul>
<li>生命周期用来描述引用的有效范围。</li>
<li>Rust 编译器通过生命周期来检查引用的有效性，确保引用在使用时是有效的。</li>
</ul>
</li>
<li><p><strong>显式生命周期标注</strong>：</p>
<ul>
<li>当函数涉及多个引用参数时，可能需要显式标注生命周期。</li>
<li>生命周期参数以单引号开头，如 <code>&#39;a</code>，并放在引用类型的前面。</li>
</ul>
</li>
</ol>
<h4 id="示例：简单的生命周期标注"><a href="#示例：简单的生命周期标注" class="headerlink" title="示例：简单的生命周期标注"></a>示例：简单的生命周期标注</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;short&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>&#39;a</code> 是生命周期参数，表示 <code>x</code>、<code>y</code> 和返回值的生命周期是相同的，即它们都必须在调用者的上下文中有效。</p>
<h3 id="与其他语言的不同之处"><a href="#与其他语言的不同之处" class="headerlink" title="与其他语言的不同之处"></a>与其他语言的不同之处</h3><ol>
<li><p><strong>编译时检查</strong>：</p>
<ul>
<li>Rust 的生命周期是在编译时检查的，而不像其他一些语言（如 C/C++）在运行时才会出现悬垂指针问题。</li>
<li>通过编译时检查，Rust 保证了内存安全，避免了悬垂引用和数据竞争。</li>
</ul>
</li>
<li><p><strong>显式生命周期注解</strong>：</p>
<ul>
<li>在 Rust 中，有时需要显式地标注生命周期，特别是在函数签名中。这在其他语言中通常是隐式处理的。</li>
<li>这种显式性增强了代码的可读性和可维护性，明确了引用的关系和作用域。</li>
</ul>
</li>
<li><p><strong>借用检查器</strong>：</p>
<ul>
<li>Rust 的借用检查器（borrow checker）会在编译时确保所有引用在其生命周期内有效，防止数据竞争和悬垂指针。</li>
<li>这与手动管理内存的语言（如 C/C++）形成鲜明对比，在这些语言中，程序员需要自行保证引用的有效性。</li>
</ul>
</li>
</ol>
<h3 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h3><p>在许多情况下，Rust 编译器可以通过生命周期消除（lifetime elision）推断生命周期参数，减少显式标注的需要。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器会推断出这个函数的生命周期标注</span></span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>生命周期</strong>：用于管理引用的有效范围，防止悬垂引用和数据竞争。</li>
<li><strong>显式标注</strong>：需要在函数签名中显式标注生命周期参数，以描述引用之间的关系。</li>
<li><strong>编译时检查</strong>：Rust 的生命周期检查在编译时进行，确保内存安全。</li>
<li><strong>与其他语言不同</strong>：Rust 的显式生命周期和编译时检查机制，与其他手动管理内存的语言形成对比，提高了内存安全性和代码可读性。</li>
</ul>
<p>通过生命周期系统，Rust 在保证内存安全的同时，保持了高效的性能和灵活性。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>在 Rust 中，虽然没有像 C++ 或 Java 那样直接的面向对象（OO）语法，但它通过结构体、特征（traits）和方法实现了面向对象的核心概念：封装、继承和多态。</p>
<h3 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h3><p>封装是通过定义结构体（struct）和实现方法（impl）来实现的。</p>
<h4 id="示例：封装"><a href="#示例：封装" class="headerlink" title="示例：封装"></a>示例：封装</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数，类似于静态方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法，具有不可变借用 &amp;self</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle::<span class="title function_ invoke__">new</span>(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>, rect.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h3><p>Rust 没有传统的继承，但可以通过特征（traits）实现类似的行为。通过特征定义共享的行为，并在结构体中实现这些特征。</p>
<h4 id="示例：继承（通过特征）"><a href="#示例：继承（通过特征）" class="headerlink" title="示例：继承（通过特征）"></a>示例：继承（通过特征）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    radius: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        std::<span class="type">f64</span>::consts::PI * <span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    side: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.side * <span class="keyword">self</span>.side</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle</span> = Circle &#123; radius: <span class="number">5.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">square</span> = Square &#123; side: <span class="number">4.0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Circle area: &#123;&#125;&quot;</span>, circle.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Square area: &#123;&#125;&quot;</span>, square.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><p>多态通过特征对象（trait objects）和动态分发（dynamic dispatch）实现。可以在运行时通过特征对象调用不同类型的实现。</p>
<h4 id="示例：多态"><a href="#示例：多态" class="headerlink" title="示例：多态"></a>示例：多态</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    radius: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        std::<span class="type">f64</span>::consts::PI * <span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    side: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.side * <span class="keyword">self</span>.side</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_area</span>(shape: &amp;<span class="keyword">dyn</span> Shape) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The area is &#123;&#125;&quot;</span>, shape.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">circle</span> = Circle &#123; radius: <span class="number">5.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">square</span> = Square &#123; side: <span class="number">4.0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_area</span>(&amp;circle);</span><br><span class="line">    <span class="title function_ invoke__">print_area</span>(&amp;square);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>print_area</code> 函数接受一个实现了 <code>Shape</code> 特征的引用。无论传递的是 <code>Circle</code> 还是 <code>Square</code>，都会调用对应的 <code>area</code> 方法，这就是多态的实现。</p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>封装</strong>：使用结构体（struct）和方法（impl）实现，将数据和行为封装在一起。</li>
<li><strong>继承</strong>：通过特征（traits）实现类似继承的行为，共享方法定义。</li>
<li><strong>多态</strong>：使用特征对象（trait objects）和动态分发（dynamic dispatch）实现多态。</li>
</ul>
<p>通过这些机制，Rust 提供了强大的抽象能力，同时保持了内存安全和高性能。</p>
<h2 id="rust并发编程"><a href="#rust并发编程" class="headerlink" title="rust并发编程"></a>rust并发编程</h2><ul>
<li><strong>并发</strong>：在同一时间段内处理多个任务，通过任务切换交替执行。（Concurrency）</li>
<li><strong>并行</strong>：在同一时刻同时执行多个任务，通过多个处理单元同时执行。（Parallelism）<br>Rust 的并发编程提供了几种方式来实现线程和任务并行执行，重点在于安全性和效率。以下是一些最常用的方法，用最简单的方式来说明。</li>
</ul>
<h3 id="1-使用-std-thread"><a href="#1-使用-std-thread" class="headerlink" title="1. 使用 std::thread"></a>1. 使用 <code>std::thread</code></h3><p>Rust 的标准库提供了线程支持，可以使用 <code>std::thread</code> 创建和管理线程。</p>
<h4 id="示例：创建一个简单的线程"><a href="#示例：创建一个简单的线程" class="headerlink" title="示例：创建一个简单的线程"></a>示例：创建一个简单的线程</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello from the spawned thread! Number &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程的工作</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello from the main thread! Number &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待创建的线程完成</span></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，主线程和新创建的线程同时执行各自的任务。</p>
<h3 id="2-使用-std-sync-mpsc-进行线程间通信"><a href="#2-使用-std-sync-mpsc-进行线程间通信" class="headerlink" title="2. 使用 std::sync::mpsc 进行线程间通信"></a>2. 使用 <code>std::sync::mpsc</code> 进行线程间通信</h3><p>Rust 提供了 <code>mpsc</code>（multiple producer, single consumer）通道，用于在线程之间传递消息。</p>
<h4 id="示例：在线程之间传递消息"><a href="#示例：在线程之间传递消息" class="headerlink" title="示例：在线程之间传递消息"></a>示例：在线程之间传递消息</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程，并发送消息</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello from the thread&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-std-sync-Mutex-进行共享状态的并发访问"><a href="#3-使用-std-sync-Mutex-进行共享状态的并发访问" class="headerlink" title="3. 使用 std::sync::Mutex 进行共享状态的并发访问"></a>3. 使用 <code>std::sync::Mutex</code> 进行共享状态的并发访问</h3><p>Rust 提供了 <code>Mutex</code> 来确保只有一个线程可以访问共享数据。</p>
<h4 id="示例：使用-Mutex-进行共享数据访问"><a href="#示例：使用-Mutex-进行共享数据访问" class="headerlink" title="示例：使用 Mutex 进行共享数据访问"></a>示例：使用 <code>Mutex</code> 进行共享数据访问</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>Arc</code>（原子引用计数）用于在多个线程之间共享 <code>Mutex</code>，<code>Mutex</code> 确保每次只有一个线程能够修改 <code>counter</code>。</p>
<h3 id="4-使用-async-和-await-进行异步编程"><a href="#4-使用-async-和-await-进行异步编程" class="headerlink" title="4. 使用 async 和 await 进行异步编程"></a>4. 使用 <code>async</code> 和 <code>await</code> 进行异步编程</h3><p>Rust 的异步编程通过 <code>async</code> 和 <code>await</code> 关键字来实现，通常与异步运行时库（如 Tokio）一起使用。</p>
<h4 id="示例：异步函数和任务"><a href="#示例：异步函数和任务" class="headerlink" title="示例：异步函数和任务"></a>示例：异步函数和任务</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::time::&#123;sleep, Duration&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task1</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Task 1 completed&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task2</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Task 2 completed&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    tokio::join!(task1, task2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All tasks completed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，两个异步任务 <code>task1</code> 和 <code>task2</code> 被并发执行，并使用 <code>tokio::join!</code> 来等待它们完成。</p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>std::thread</code></strong>：用于创建和管理线程。</li>
<li><strong><code>std::sync::mpsc</code></strong>：用于线程间的消息传递。</li>
<li><strong><code>std::sync::Mutex</code></strong>：用于共享状态的安全访问。</li>
<li><strong><code>async</code> 和 <code>await</code></strong>：用于异步编程，通常与异步运行时库（如 Tokio）一起使用。</li>
</ul>
<p>Rust 的并发编程通过这些工具和概念，提供了安全高效的并发执行方式。<br>好的，在 Rust 中，除了 <code>std::sync::mpsc</code> 提供的通道（channel），还有其他库提供的通道，比如 <code>crossbeam</code>，它提供了更强大和灵活的并发工具。下面我们结合 <code>std::sync::mpsc</code> 和 <code>crossbeam</code>，重新讲解 Rust 中的并发编程。</p>
<h3 id="1-使用-std-thread-1"><a href="#1-使用-std-thread-1" class="headerlink" title="1. 使用 std::thread"></a>1. 使用 <code>std::thread</code></h3><p>Rust 的标准库提供了线程支持，可以使用 <code>std::thread</code> 创建和管理线程。</p>
<h4 id="示例：创建一个简单的线程-1"><a href="#示例：创建一个简单的线程-1" class="headerlink" title="示例：创建一个简单的线程"></a>示例：创建一个简单的线程</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello from the spawned thread! Number &#123;&#125;&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程的工作</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello from the main thread! Number &#123;&#125;&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待创建的线程完成</span></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-std-sync-mpsc-进行线程间通信-1"><a href="#2-使用-std-sync-mpsc-进行线程间通信-1" class="headerlink" title="2. 使用 std::sync::mpsc 进行线程间通信"></a>2. 使用 <code>std::sync::mpsc</code> 进行线程间通信</h3><p>Rust 提供了 <code>mpsc</code>（multiple producer, single consumer）通道，用于在线程之间传递消息。</p>
<h4 id="示例：在线程之间传递消息-1"><a href="#示例：在线程之间传递消息-1" class="headerlink" title="示例：在线程之间传递消息"></a>示例：在线程之间传递消息</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程，并发送消息</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello from the thread&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-std-sync-Mutex-进行共享状态的并发访问-1"><a href="#3-使用-std-sync-Mutex-进行共享状态的并发访问-1" class="headerlink" title="3. 使用 std::sync::Mutex 进行共享状态的并发访问"></a>3. 使用 <code>std::sync::Mutex</code> 进行共享状态的并发访问</h3><p>Rust 提供了 <code>Mutex</code> 来确保只有一个线程可以访问共享数据。</p>
<h4 id="示例：使用-Mutex-进行共享数据访问-1"><a href="#示例：使用-Mutex-进行共享数据访问-1" class="headerlink" title="示例：使用 Mutex 进行共享数据访问"></a>示例：使用 <code>Mutex</code> 进行共享数据访问</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>Arc</code>（原子引用计数）用于在多个线程之间共享 <code>Mutex</code>，<code>Mutex</code> 确保每次只有一个线程能够修改 <code>counter</code>。</p>
<h3 id="4-使用-crossbeam-的通道"><a href="#4-使用-crossbeam-的通道" class="headerlink" title="4. 使用 crossbeam 的通道"></a>4. 使用 <code>crossbeam</code> 的通道</h3><p><code>crossbeam</code> 是一个更强大和灵活的并发库，提供了多种并发原语，包括通道。</p>
<h4 id="示例：使用-crossbeam-的通道"><a href="#示例：使用-crossbeam-的通道" class="headerlink" title="示例：使用 crossbeam 的通道"></a>示例：使用 <code>crossbeam</code> 的通道</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crossbeam::channel;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (s, r) = channel::<span class="title function_ invoke__">unbounded</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = s.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            s.<span class="title function_ invoke__">send</span>(i).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Sent: &#123;&#125;&quot;</span>, i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">received</span> = r.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Received: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>crossbeam::channel::unbounded</code> 创建了一个无界通道，允许任意多的消息发送和接收。</p>
<h3 id="5-使用-async-和-await-进行异步编程"><a href="#5-使用-async-和-await-进行异步编程" class="headerlink" title="5. 使用 async 和 await 进行异步编程"></a>5. 使用 <code>async</code> 和 <code>await</code> 进行异步编程</h3><p>Rust 的异步编程通过 <code>async</code> 和 <code>await</code> 关键字来实现，通常与异步运行时库（如 Tokio）一起使用。</p>
<h4 id="示例：异步函数和任务-1"><a href="#示例：异步函数和任务-1" class="headerlink" title="示例：异步函数和任务"></a>示例：异步函数和任务</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::time::&#123;sleep, Duration&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task1</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Task 1 completed&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task2</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Task 2 completed&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    tokio::join!(task1, task2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All tasks completed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，两个异步任务 <code>task1</code> 和 <code>task2</code> 被并发执行，并使用 <code>tokio::join!</code> 来等待它们完成。</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>std::thread</code></strong>：用于创建和管理线程。</li>
<li><strong><code>std::sync::mpsc</code></strong>：用于线程间的消息传递，支持多个生产者单个消费者。</li>
<li><strong><code>std::sync::Mutex</code></strong>：用于共享状态的安全访问。</li>
<li><strong><code>crossbeam::channel</code></strong>：提供了更灵活的通道，支持多种并发模式。</li>
<li><strong><code>async</code> 和 <code>await</code></strong>：用于异步编程，通常与异步运行时库（如 Tokio）一起使用。</li>
</ul>
<p>Rust 的并发编程通过这些工具和概念，提供了安全高效的并发执行方式，适用于不同的并发场景。</p>
<h2 id="Rust-智能指针"><a href="#Rust-智能指针" class="headerlink" title="Rust 智能指针"></a>Rust 智能指针</h2><p>在 Rust 中，智能指针（Smart Pointers）是一种具有指针行为的数据结构，不仅能够指向某个值，还包含额外的元数据和功能。Rust 的智能指针提供了更高的安全性和便捷性，通过所有权和借用规则来管理内存，避免了手动管理内存的常见问题。以下是 Rust 中常用的几种智能指针及其用途。</p>
<h3 id="1-Box-lt-T-gt"><a href="#1-Box-lt-T-gt" class="headerlink" title="1. Box&lt;T&gt;"></a>1. <code>Box&lt;T&gt;</code></h3><p><code>Box&lt;T&gt;</code> 是最简单的智能指针，用于在堆上分配值。它提供了对数据的所有权，但不会引入额外的开销。</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>Box::new</code> 在堆上分配了一个值 <code>5</code>，并返回一个指向该值的 <code>Box&lt;T&gt;</code>。</p>
<h3 id="2-Rc-lt-T-gt"><a href="#2-Rc-lt-T-gt" class="headerlink" title="2. Rc&lt;T&gt;"></a>2. <code>Rc&lt;T&gt;</code></h3><p><code>Rc&lt;T&gt;</code> 是一个引用计数智能指针，用于在多个所有者之间共享数据。它允许多个变量持有同一个值的所有权，但只能用于单线程环境。</p>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;, c = &#123;&#125;&quot;</span>, a, b, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Reference count: &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>Rc::clone</code> 创建了指向同一值的多个引用，并增加了引用计数。</p>
<h3 id="3-Arc-lt-T-gt"><a href="#3-Arc-lt-T-gt" class="headerlink" title="3. Arc&lt;T&gt;"></a>3. <code>Arc&lt;T&gt;</code></h3><p><code>Arc&lt;T&gt;</code> 是一个原子引用计数智能指针，类似于 <code>Rc&lt;T&gt;</code>，但可以在线程之间安全地共享数据。它用于需要跨线程共享所有权的场景。</p>
<h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>Arc::clone</code> 创建了跨线程共享的引用。</p>
<h3 id="4-RefCell-lt-T-gt"><a href="#4-RefCell-lt-T-gt" class="headerlink" title="4. RefCell&lt;T&gt;"></a>4. <code>RefCell&lt;T&gt;</code></h3><p><code>RefCell&lt;T&gt;</code> 允许在运行时检查借用规则，而不是在编译时。它提供了内部可变性，即使在不可变环境中也可以修改数据。<code>RefCell</code> 仅用于单线程环境。</p>
<h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    *x.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">borrow</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>RefCell::borrow_mut</code> 和 <code>RefCell::borrow</code> 用于可变和不可变借用，分别在运行时检查借用规则。</p>
<h3 id="5-Mutex-lt-T-gt"><a href="#5-Mutex-lt-T-gt" class="headerlink" title="5. Mutex&lt;T&gt;"></a>5. <code>Mutex&lt;T&gt;</code></h3><p><code>Mutex&lt;T&gt;</code> 提供互斥锁机制，用于在线程之间安全地共享数据。它确保一次只有一个线程可以访问数据。</p>
<h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>Mutex::lock</code> 获取互斥锁，确保一次只有一个线程可以访问和修改 <code>counter</code>。</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Box&lt;T&gt;</code></strong>：用于在堆上分配值，提供简单的所有权。</li>
<li><strong><code>Rc&lt;T&gt;</code></strong>：用于单线程环境下的引用计数共享所有权。</li>
<li><strong><code>Arc&lt;T&gt;</code></strong>：用于多线程环境下的原子引用计数共享所有权。</li>
<li><strong><code>RefCell&lt;T&gt;</code></strong>：提供运行时的内部可变性检查，适用于单线程环境。</li>
<li><strong><code>Mutex&lt;T&gt;</code></strong>：提供互斥锁机制，确保线程安全的共享访问。</li>
</ul>
<p>Rust 的智能指针通过所有权、借用和引用计数等机制，提供了安全高效的内存管理，避免了手动管理内存的常见问题。</p>
<h2 id="rust异步编程"><a href="#rust异步编程" class="headerlink" title="rust异步编程"></a>rust异步编程</h2><p>Rust 的异步编程（asynchronous programming）提供了一种处理并发任务的方式，避免了传统多线程编程中的复杂性和开销。通过使用 <code>async</code> 和 <code>await</code> 关键字，Rust 能够以异步的方式执行代码，这对于 IO 密集型任务非常有效，比如网络请求、文件操作等。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><strong>async/await</strong>：Rust 使用 <code>async</code> 关键字定义异步函数，使用 <code>await</code> 关键字等待异步操作完成。</li>
<li><strong>Future</strong>：异步函数返回一个 <code>Future</code>，它代表一个在某个时间点将要完成的值。</li>
<li><strong>Executor</strong>：执行异步任务的运行时环境，常用的有 <code>Tokio</code> 和 <code>async-std</code>。</li>
</ol>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>使用 <code>async</code> 和 <code>await</code> 关键字可以让你以同步的方式编写异步代码。</p>
<h4 id="示例：基本的-async-await"><a href="#示例：基本的-async-await" class="headerlink" title="示例：基本的 async/await"></a>示例：基本的 async/await</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::time::&#123;sleep, Duration&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task1</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Task 1 completed&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task2</span> = <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Task 2 completed&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    tokio::join!(task1, task2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All tasks completed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，两个异步任务 <code>task1</code> 和 <code>task2</code> 并发执行，并使用 <code>tokio::join!</code> 等待它们完成。</p>
<h3 id="使用-Tokio-运行时"><a href="#使用-Tokio-运行时" class="headerlink" title="使用 Tokio 运行时"></a>使用 Tokio 运行时</h3><p><code>Tokio</code> 是 Rust 中常用的异步运行时，它提供了执行异步任务的环境。</p>
<h4 id="示例：使用-Tokio-进行异步操作"><a href="#示例：使用-Tokio-进行异步操作" class="headerlink" title="示例：使用 Tokio 进行异步操作"></a>示例：使用 Tokio 进行异步操作</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> tokio::time::&#123;sleep, Duration&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">perform_task</span>(name: &amp;<span class="type">str</span>, duration: <span class="type">u64</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(duration)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; completed&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task1</span> = <span class="title function_ invoke__">perform_task</span>(<span class="string">&quot;Task 1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task2</span> = <span class="title function_ invoke__">perform_task</span>(<span class="string">&quot;Task 2&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    tokio::join!(task1, task2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All tasks completed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>perform_task</code> 是一个异步函数，接受任务名称和持续时间。<code>main</code> 函数使用 <code>tokio::join!</code> 并发执行两个任务。</p>
<h3 id="异步函数和-Future"><a href="#异步函数和-Future" class="headerlink" title="异步函数和 Future"></a>异步函数和 Future</h3><p>异步函数返回一个 <code>Future</code>，表示一个尚未完成的计算。你可以手动创建和操作 <code>Future</code>。</p>
<h4 id="示例：手动创建-Future"><a href="#示例：手动创建-Future" class="headerlink" title="示例：手动创建 Future"></a>示例：手动创建 Future</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::Future;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::task::&#123;Context, Poll&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleFuture</span> &#123;</span><br><span class="line">    completed: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Future</span> <span class="keyword">for</span> <span class="title class_">SimpleFuture</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">poll</span>(<span class="keyword">mut</span> <span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, _cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.completed &#123;</span><br><span class="line">            Poll::<span class="title function_ invoke__">Ready</span>(<span class="string">&quot;Future completed&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.completed = <span class="literal">true</span>;</span><br><span class="line">            Poll::Pending</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_future</span> = SimpleFuture &#123; completed: <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = my_future.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>SimpleFuture</code> 是一个自定义的 <code>Future</code>，它在第一次调用 <code>poll</code> 时返回 <code>Poll::Pending</code>，在第二次调用时返回 <code>Poll::Ready</code>。</p>
<h3 id="异步编程的优势"><a href="#异步编程的优势" class="headerlink" title="异步编程的优势"></a>异步编程的优势</h3><ul>
<li><strong>高效 IO</strong>：异步编程可以高效地处理 IO 操作，不需要为每个任务创建一个线程，从而节省资源。</li>
<li><strong>提高响应性</strong>：通过异步编程，可以在等待某个任务完成时执行其他任务，提高程序的响应性。</li>
</ul>
<h3 id="使用-async-std"><a href="#使用-async-std" class="headerlink" title="使用 async-std"></a>使用 async-std</h3><p>除了 <code>Tokio</code>，还有另一个常用的异步运行时库 <code>async-std</code>。</p>
<h4 id="示例：使用-async-std"><a href="#示例：使用-async-std" class="headerlink" title="示例：使用 async-std"></a>示例：使用 async-std</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> async_std::task;</span><br><span class="line"><span class="keyword">use</span> async_std::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">perform_task</span>(name: &amp;<span class="type">str</span>, duration: <span class="type">u64</span>) &#123;</span><br><span class="line">    task::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(duration)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; completed&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    task::<span class="title function_ invoke__">block_on</span>(<span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task1</span> = <span class="title function_ invoke__">perform_task</span>(<span class="string">&quot;Task 1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task2</span> = <span class="title function_ invoke__">perform_task</span>(<span class="string">&quot;Task 2&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        futures::join!(task1, task2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;All tasks completed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，使用 <code>async-std</code> 运行时来执行异步任务。</p>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>async/await</strong>：Rust 提供的关键字，用于定义和执行异步函数。</li>
<li><strong>Future</strong>：表示一个尚未完成的计算，异步函数返回 <code>Future</code>。</li>
<li><strong>Executor</strong>：执行异步任务的运行时环境，如 <code>Tokio</code> 和 <code>async-std</code>。</li>
<li><strong>高效 IO 和响应性</strong>：异步编程能够高效处理 IO 操作并提高程序的响应性。</li>
</ul>
<p>通过以上示例和概念，您可以开始在 Rust 中编写和执行异步代码，提高程序的性能和效率。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://www.runoob.com/rust/rust-tutorial.html">rust菜鸟文档</a></li>
<li>[2] <a target="_blank" rel="noopener" href="https://www.rust-lang.org/zh-CN/">rust官网</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/rust/" rel="tag"># rust</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/14/vcpkg-c++%E5%8C%85%E7%AE%A1%E7%90%86/" rel="prev" title="vcpkg-c++包管理">
      <i class="fa fa-chevron-left"></i> vcpkg-c++包管理
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/08/Unity-Crazy-car/" rel="next" title="Unity-Crazy-car">
      Unity-Crazy-car <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">语言特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">rust安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cargo-%E6%95%99%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">cargo 教程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E8%BE%93%E5%87%BA%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">1.4.</span> <span class="nav-text">rust输出命令行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">Rust基本语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">rust数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B%EF%BC%88Integer%EF%BC%89"><span class="nav-number">1.6.1.</span> <span class="nav-text">整数型（Integer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9E%8B%EF%BC%88Floating-Point%EF%BC%89"><span class="nav-number">1.6.2.</span> <span class="nav-text">浮点数型（Floating-Point）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="nav-number">1.6.3.</span> <span class="nav-text">数学运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.</span> <span class="nav-text">rust注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">rust函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E6%9D%A1%E4%BB%B6%E5%8F%A5%E5%AD%90"><span class="nav-number">1.9.</span> <span class="nav-text">rust条件句子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.10.</span> <span class="nav-text">rust循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.11.</span> <span class="nav-text">rust迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.11.1.</span> <span class="nav-text">创建迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">数组迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">向量迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">范围迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.11.2.</span> <span class="nav-text">使用迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">1.11.3.</span> <span class="nav-text">常用迭代器适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filter"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collect"><span class="nav-number">1.11.3.3.</span> <span class="nav-text">collect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fold"><span class="nav-number">1.11.3.4.</span> <span class="nav-text">fold</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.11.4.</span> <span class="nav-text">自定义迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.11.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E9%97%AD%E5%8C%85"><span class="nav-number">1.12.</span> <span class="nav-text">rust闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.12.1.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-number">1.12.2.</span> <span class="nav-text">类型推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.12.3.</span> <span class="nav-text">闭包的三种类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">1.12.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">1.13.</span> <span class="nav-text">rust所有权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="nav-number">1.13.1.</span> <span class="nav-text">所有权的基本规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">1.13.2.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">1. 变量的所有权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB%EF%BC%88%E7%A7%BB%E5%8A%A8%EF%BC%89"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">2. 所有权转移（移动）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%85%8B%E9%9A%86"><span class="nav-number">1.13.2.3.</span> <span class="nav-text">3. 克隆</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8"><span class="nav-number">1.13.3.</span> <span class="nav-text">引用和借用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="nav-number">1.13.3.1.</span> <span class="nav-text">1. 不可变引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="nav-number">1.13.3.2.</span> <span class="nav-text">2. 可变引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8%EF%BC%88Dangling-References%EF%BC%89"><span class="nav-number">1.13.4.</span> <span class="nav-text">悬垂引用（Dangling References）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="nav-number">1.13.5.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E5%88%87%E7%89%87"><span class="nav-number">1.14.</span> <span class="nav-text">rust切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.14.1.</span> <span class="nav-text">错误的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.2.</span> <span class="nav-text">解决方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.15.</span> <span class="nav-text">rust结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88C-like-Struct%EF%BC%89"><span class="nav-number">1.15.1.</span> <span class="nav-text">1. 经典结构体（C-like Struct）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.15.1.1.</span> <span class="nav-text">定义和使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Tuple-Struct%EF%BC%89"><span class="nav-number">1.15.2.</span> <span class="nav-text">2. 元组结构体（Tuple Struct）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8-1"><span class="nav-number">1.15.2.1.</span> <span class="nav-text">定义和使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Unit-like-Struct%EF%BC%89"><span class="nav-number">1.15.3.</span> <span class="nav-text">3. 单元结构体（Unit-like Struct）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8-2"><span class="nav-number">1.15.3.1.</span> <span class="nav-text">定义和使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.15.4.</span> <span class="nav-text">结构体的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.15.4.1.</span> <span class="nav-text">方法和关联函数示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">1.15.5.</span> <span class="nav-text">结构体的所有权</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.15.5.1.</span> <span class="nav-text">生命周期示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.16.</span> <span class="nav-text">rust枚举类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.16.1.</span> <span class="nav-text">定义和使用枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.16.1.1.</span> <span class="nav-text">基本枚举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.16.1.2.</span> <span class="nav-text">带数据的枚举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Option%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.16.2.</span> <span class="nav-text">使用Option枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Result%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.16.3.</span> <span class="nav-text">使用Result枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.16.4.</span> <span class="nav-text">方法和枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.16.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86"><span class="nav-number">1.17.</span> <span class="nav-text">rust组织管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Crate"><span class="nav-number">1.17.1.</span> <span class="nav-text">1. Crate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="nav-number">1.17.1.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Package"><span class="nav-number">1.17.2.</span> <span class="nav-text">2. Package</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="nav-number">1.17.2.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Module"><span class="nav-number">1.17.3.</span> <span class="nav-text">3. Module</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-3"><span class="nav-number">1.17.3.1.</span> <span class="nav-text">示例：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97"><span class="nav-number">1.17.3.2.</span> <span class="nav-text">定义和使用模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">1.17.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Package-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">1.17.5.</span> <span class="nav-text">Package 的核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Package"><span class="nav-number">1.17.6.</span> <span class="nav-text">创建 Package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cargo-toml-%E6%96%87%E4%BB%B6"><span class="nav-number">1.17.7.</span> <span class="nav-text">Cargo.toml 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA-Crate"><span class="nav-number">1.17.8.</span> <span class="nav-text">包含多个 Crate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81"><span class="nav-number">1.17.9.</span> <span class="nav-text">使用模块组织代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">1.17.10.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.18.</span> <span class="nav-text">rust错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-Result-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">1.18.1.</span> <span class="nav-text">1. 使用 Result 处理错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">1.18.1.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.18.1.2.</span> <span class="nav-text">? 运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-Option-%E5%A4%84%E7%90%86%E5%80%BC%E7%9A%84%E5%AD%98%E5%9C%A8%E6%80%A7"><span class="nav-number">1.18.2.</span> <span class="nav-text">2. 使用 Option 处理值的存在性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">1.18.2.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.18.3.</span> <span class="nav-text">3. 自定义错误类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="nav-number">1.18.3.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%94%99%E8%AF%AF%E4%BC%A0%E6%92%AD"><span class="nav-number">1.18.4.</span> <span class="nav-text">4. 错误传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">1.18.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E4%B8%AD%E7%9A%84panic"><span class="nav-number">1.19.</span> <span class="nav-text">rust中的panic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-panic-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">1.19.1.</span> <span class="nav-text">1. panic! 的基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8D%95%E8%8E%B7-panic%EF%BC%9A%E4%BD%BF%E7%94%A8-std-panic-catch-unwind"><span class="nav-number">1.19.2.</span> <span class="nav-text">2. 捕获 panic：使用 std::panic::catch_unwind</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="nav-number">1.19.2.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%81%A2%E5%A4%8D%EF%BC%88unwind%EF%BC%89%E4%B8%8E%E7%BB%88%E6%AD%A2%EF%BC%88abort%EF%BC%89"><span class="nav-number">1.19.3.</span> <span class="nav-text">3. 恢复（unwind）与终止（abort）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89-panic-%E8%A1%8C%E4%B8%BA%EF%BC%9Astd-panic-set-hook"><span class="nav-number">1.19.4.</span> <span class="nav-text">4. 自定义 panic 行为：std::panic::set_hook</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="nav-number">1.19.4.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%81%BF%E5%85%8D-panic"><span class="nav-number">1.19.5.</span> <span class="nav-text">5. 避免 panic</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Result-%E4%BB%A3%E6%9B%BF-panic"><span class="nav-number">1.19.5.1.</span> <span class="nav-text">示例：使用 Result 代替 panic</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">1.19.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81"><span class="nav-number">1.20.</span> <span class="nav-text">rust泛型特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%EF%BC%88Generics%EF%BC%89"><span class="nav-number">1.20.1.</span> <span class="nav-text">Rust 中的泛型（Generics）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="nav-number">1.20.1.1.</span> <span class="nav-text">示例：泛型函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.20.1.2.</span> <span class="nav-text">示例：泛型结构体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%88Traits%EF%BC%89"><span class="nav-number">1.20.2.</span> <span class="nav-text">Rust 中的特征（Traits）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%89%B9%E5%BE%81"><span class="nav-number">1.20.2.1.</span> <span class="nav-text">示例：定义和实现特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%B8%A6%E6%9C%89%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="nav-number">1.20.2.2.</span> <span class="nav-text">示例：带有特征约束的泛型函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">1.20.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.21.</span> <span class="nav-text">rust生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rust-%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.21.1.</span> <span class="nav-text">Rust 中的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="nav-number">1.21.1.1.</span> <span class="nav-text">示例：简单的生命周期标注</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="nav-number">1.21.2.</span> <span class="nav-text">与其他语言的不同之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B6%88%E9%99%A4"><span class="nav-number">1.21.3.</span> <span class="nav-text">生命周期消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-7"><span class="nav-number">1.21.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.22.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88Encapsulation%EF%BC%89"><span class="nav-number">1.22.1.</span> <span class="nav-text">封装（Encapsulation）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%B0%81%E8%A3%85"><span class="nav-number">1.22.1.1.</span> <span class="nav-text">示例：封装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%88Inheritance%EF%BC%89"><span class="nav-number">1.22.2.</span> <span class="nav-text">继承（Inheritance）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BB%A7%E6%89%BF%EF%BC%88%E9%80%9A%E8%BF%87%E7%89%B9%E5%BE%81%EF%BC%89"><span class="nav-number">1.22.2.1.</span> <span class="nav-text">示例：继承（通过特征）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%EF%BC%88Polymorphism%EF%BC%89"><span class="nav-number">1.22.3.</span> <span class="nav-text">多态（Polymorphism）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%A4%9A%E6%80%81"><span class="nav-number">1.22.3.1.</span> <span class="nav-text">示例：多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-8"><span class="nav-number">1.22.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.23.</span> <span class="nav-text">rust并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-std-thread"><span class="nav-number">1.23.1.</span> <span class="nav-text">1. 使用 std::thread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.23.1.1.</span> <span class="nav-text">示例：创建一个简单的线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-std-sync-mpsc-%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.23.2.</span> <span class="nav-text">2. 使用 std::sync::mpsc 进行线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF"><span class="nav-number">1.23.2.1.</span> <span class="nav-text">示例：在线程之间传递消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8-std-sync-Mutex-%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE"><span class="nav-number">1.23.3.</span> <span class="nav-text">3. 使用 std::sync::Mutex 进行共享状态的并发访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Mutex-%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="nav-number">1.23.3.1.</span> <span class="nav-text">示例：使用 Mutex 进行共享数据访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8-async-%E5%92%8C-await-%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.23.4.</span> <span class="nav-text">4. 使用 async 和 await 进行异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.23.4.1.</span> <span class="nav-text">示例：异步函数和任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-9"><span class="nav-number">1.23.5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-std-thread-1"><span class="nav-number">1.23.6.</span> <span class="nav-text">1. 使用 std::thread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B-1"><span class="nav-number">1.23.6.1.</span> <span class="nav-text">示例：创建一个简单的线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-std-sync-mpsc-%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-1"><span class="nav-number">1.23.7.</span> <span class="nav-text">2. 使用 std::sync::mpsc 进行线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF-1"><span class="nav-number">1.23.7.1.</span> <span class="nav-text">示例：在线程之间传递消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8-std-sync-Mutex-%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E7%9A%84%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE-1"><span class="nav-number">1.23.8.</span> <span class="nav-text">3. 使用 std::sync::Mutex 进行共享状态的并发访问</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Mutex-%E8%BF%9B%E8%A1%8C%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE-1"><span class="nav-number">1.23.8.1.</span> <span class="nav-text">示例：使用 Mutex 进行共享数据访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8-crossbeam-%E7%9A%84%E9%80%9A%E9%81%93"><span class="nav-number">1.23.9.</span> <span class="nav-text">4. 使用 crossbeam 的通道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-crossbeam-%E7%9A%84%E9%80%9A%E9%81%93"><span class="nav-number">1.23.9.1.</span> <span class="nav-text">示例：使用 crossbeam 的通道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8-async-%E5%92%8C-await-%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.23.10.</span> <span class="nav-text">5. 使用 async 和 await 进行异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C%E4%BB%BB%E5%8A%A1-1"><span class="nav-number">1.23.10.1.</span> <span class="nav-text">示例：异步函数和任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-10"><span class="nav-number">1.23.11.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.24.</span> <span class="nav-text">Rust 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Box-lt-T-gt"><span class="nav-number">1.24.1.</span> <span class="nav-text">1. Box&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="nav-number">1.24.1.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Rc-lt-T-gt"><span class="nav-number">1.24.2.</span> <span class="nav-text">2. Rc&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="nav-number">1.24.2.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Arc-lt-T-gt"><span class="nav-number">1.24.3.</span> <span class="nav-text">3. Arc&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-9"><span class="nav-number">1.24.3.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-RefCell-lt-T-gt"><span class="nav-number">1.24.4.</span> <span class="nav-text">4. RefCell&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-10"><span class="nav-number">1.24.4.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Mutex-lt-T-gt"><span class="nav-number">1.24.5.</span> <span class="nav-text">5. Mutex&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-11"><span class="nav-number">1.24.5.1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-11"><span class="nav-number">1.24.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.25.</span> <span class="nav-text">rust异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.25.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-%E5%92%8C-await"><span class="nav-number">1.25.2.</span> <span class="nav-text">async 和 await</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%9A%84-async-await"><span class="nav-number">1.25.2.1.</span> <span class="nav-text">示例：基本的 async&#x2F;await</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Tokio-%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="nav-number">1.25.3.</span> <span class="nav-text">使用 Tokio 运行时</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Tokio-%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">1.25.3.1.</span> <span class="nav-text">示例：使用 Tokio 进行异步操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%92%8C-Future"><span class="nav-number">1.25.4.</span> <span class="nav-text">异步函数和 Future</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA-Future"><span class="nav-number">1.25.4.1.</span> <span class="nav-text">示例：手动创建 Future</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.25.5.</span> <span class="nav-text">异步编程的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-async-std"><span class="nav-number">1.25.6.</span> <span class="nav-text">使用 async-std</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-async-std"><span class="nav-number">1.25.6.1.</span> <span class="nav-text">示例：使用 async-std</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-12"><span class="nav-number">1.25.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">1.26.</span> <span class="nav-text">引用</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Abel Sean"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Abel Sean</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://blog.csdn.net/erlang_hell" title="http:&#x2F;&#x2F;blog.csdn.net&#x2F;erlang_hell" rel="noopener" target="_blank">我的csdn-blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://dengwenyi88.github.io/" title="https:&#x2F;&#x2F;dengwenyi88.github.io&#x2F;" rel="noopener" target="_blank">dwy-blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://unity3d.io/" title="https:&#x2F;&#x2F;unity3d.io" rel="noopener" target="_blank">蔡总-blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Abel Sean</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b08c5201a4a52badc863',
      clientSecret: 'dd2c48988eb499969198746dae8ec2c7ccbad00b',
      repo        : 'BlogComment',
      owner       : 'swordhell',
      admin       : ['swordhell'],
      id          : '4fb6a3cb58c89e724739d4ee87ad3252',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
