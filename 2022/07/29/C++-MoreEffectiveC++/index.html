<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swordhell.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概述作为Effective C++姊妹篇，这本书也是需要刷一遍的，一共35条建议。本书成书1996年，前言里面描述，其实1990-1992当时C++就已经很火爆了，大家都想着去了解这个语言（这本书写于）。 看侯杰的版本的导读篇里面的原文：  广博如四库全书者有之（The C++ Programming Language、C++ Primer），深奥如重山复水者有之（The Annotated C+">
<meta property="og:type" content="article">
<meta property="og:title" content="C++MoreEffective-C++">
<meta property="og:url" content="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/index.html">
<meta property="og:site_name" content="Abel&#39;Blog">
<meta property="og:description" content="概述作为Effective C++姊妹篇，这本书也是需要刷一遍的，一共35条建议。本书成书1996年，前言里面描述，其实1990-1992当时C++就已经很火爆了，大家都想着去了解这个语言（这本书写于）。 看侯杰的版本的导读篇里面的原文：  广博如四库全书者有之（The C++ Programming Language、C++ Primer），深奥如重山复水者有之（The Annotated C+">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/Item.M.24.1.png">
<meta property="og:image" content="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/Item.M.24.2.png">
<meta property="og:image" content="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/Item.M.24.3.png">
<meta property="og:image" content="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/Item.M.24.4.png">
<meta property="og:image" content="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/Item.M.25.1.png">
<meta property="og:image" content="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/Item.M.27.1.png">
<meta property="article:published_time" content="2022-07-28T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-07T01:46:42.059Z">
<meta property="article:author" content="Abel Sean">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/Item.M.24.1.png">

<link rel="canonical" href="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++MoreEffective-C++ | Abel'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Abel'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我干了什么?究竟拿了时间换了什么?</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swordhell.github.io/2022/07/29/C++-MoreEffectiveC++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Abel Sean">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Abel'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++MoreEffective-C++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-29 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-29T00:00:00+08:00">2022-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-07 09:46:42" itemprop="dateModified" datetime="2023-06-07T09:46:42+08:00">2023-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">1-基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1-%E5%9F%BA%E7%A1%80/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为Effective C++姊妹篇，这本书也是需要刷一遍的，一共35条建议。本书成书1996年，前言里面描述，其实1990-1992当时C++就已经很火爆了，大家都想着去了解这个语言（这本书写于）。</p>
<p>看侯杰的版本的导读篇里面的原文：</p>
<blockquote>
<p>广博如四库全书者有之（The C++ Programming Language、C++ Primer），深奥如重山复水者有之（The Annotated C++ Reference Manual, Inside the C++ Object Model），细说历史者有之（The Design and Evolution of C++, Ruminations on C++），独沽一味者有之（Polymorphism in C++, Genericity in C++），独树一帜者有之（Design Patterns,Large Scale C++ Software Design, C++ FAQs），程式库大全有之（The C++ Standard Library），另辟蹊径者有之（Generic Programming and the STL），工程经验之累积亦有之（Effective C++, More Effective C++, Exceptional C++）。<br>这其中，「工程经验之累积」对已具 C++ 相当基础的程式员而言，有著致命的吸引力与立竿见影的帮助。Scott Meyers 的 Effective C++ 和 More Effective C++ 是此类佼佼，Herb Sutter 的 Exceptional C++ 则是後起之秀。<br>这类书籍的一个共通特色是轻薄短小，并且高密度地纳入作者浸淫於 C++/OOP 领域多年而广泛的经验。它们不但开展读者的视野，也为读者提供各种 C++/OOP 常见问题或易犯错误的解决模型。</p>
</blockquote>
<span id="more"></span>
<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><blockquote>
<p>一旦语言进入成熟期，而我们对它的使用经验也愈来愈多，我们所需要的资讯也就随之改变。1990 年人们想知道 C++ 是什么东西。到了 1992 年，他们想知道如何运用它。如今C++ 程式员问的问题更高级：我如何能够设计出适应未来需求的软体？我如何能够改善程式码的效率而不折损正确性和易用性？我如何能够实作出语言未能直接支援的精巧机能？<br>本书内容分为 35 个条款。每个条款都在特定主题上精简摘要出 C++ 程式设计社群所累积的智慧。大部份条款以准则的型式呈现，附随的说明则阐述这条准则为什么存在，如果不遵循会发生什么後果，以及什么情况下可以合理违反该准则。所有条款被我分为数大类。某些条款关心特定的语言性质，特别是你可能罕有使用经验的一些新性质。<br>例如条款 9~15 专注於 exceptions（就像 Tom Cargill, Jack Reeves, Herb Sutter 所发表的那些杂志文章一样）。<br>其他条款解释如何结合语言的不同特性以达成更高阶目标。例如条款 25~31 描述如何限制物件的个数或诞生地点，如何根据一个以上的物件型别产生出类似虚拟函式的东西，如何产生 smart pointers 等等。其他条款解决更广泛的题目。<br>条款 16~24 专注於效率上的议题。<br>不论哪一条款，提供的都是与其主题相关且意义重大的作法。在 More Effective C++一书中你将学习到如何更实效更精锐地使用 C++。</p>
</blockquote>
<h3 id="1-基础议题"><a href="#1-基础议题" class="headerlink" title="1. 基础议题"></a>1. 基础议题</h3><h4 id="Item-M1：-指针与引用的区别"><a href="#Item-M1：-指针与引用的区别" class="headerlink" title="Item M1： 指针与引用的区别"></a>Item M1： 指针与引用的区别</h4><p>因此如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该把变量声明为指针，因为这样你可以赋空值给该变量。相反，如果变量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为引用。</p>
<p>指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。但是<br>引用则总是指向在初始化时被指定的对象，以后不能改变。</p>
<h4 id="Item-M2：尽量使用C-风格的类型转换"><a href="#Item-M2：尽量使用C-风格的类型转换" class="headerlink" title="Item M2：尽量使用C++风格的类型转换"></a>Item M2：尽量使用C++风格的类型转换</h4><p>C++风格的类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> <span class="keyword">const_cast</span> <span class="keyword">dynamic_cast</span>  <span class="keyword">reinterpret_cast</span></span><br></pre></td></tr></table></figure>
<p>static_cast转换类似C语言的转换。</p>
<p>const_cast转换能去除之前附上的const属性。</p>
<p>dynamic_cast将会沿着继承关系向下安全转换，如果非此类型将会传出一个空指针。</p>
<p>reinterpret_cast 使用这个操作符的类型转换，其的转换结果几乎都是执行期定义 （ implementation-defined ）。因此，使用reinterpret_casts 的代码很难移植。</p>
<p>最普通的用途就是在函数指针类型之间进行转换。</p>
<h4 id="Item-M3：-不要对数组使用多态"><a href="#Item-M3：-不要对数组使用多态" class="headerlink" title="Item M3： 不要对数组使用多态"></a>Item M3： 不要对数组使用多态</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span> &#123; ... &#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BalancedBST</span>: <span class="keyword">public</span> BST &#123; ... &#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBSTArray</span><span class="params">(ostream&amp; s, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> BST array[], </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">int</span> numElements)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numElements; ) &#123; </span><br><span class="line"> s &lt;&lt; array[i]; <span class="comment">//假设 BST 类 </span></span><br><span class="line"> &#125; <span class="comment">//重载了操作符&lt;&lt; </span></span><br><span class="line">&#125;</span><br><span class="line">BST BSTArray[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, BSTArray, <span class="number">10</span>); <span class="comment">// 运行正常</span></span><br><span class="line">BalancedBST bBSTArray[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="built_in">printBSTArray</span>(cout, bBSTArray, <span class="number">10</span>); <span class="comment">// 还会运行正常么？ </span></span><br><span class="line"><span class="comment">// 编译器将会毫无警告地编译这个函数</span></span><br><span class="line"><span class="comment">// 它们的间隔是 i*sizeof(一个在数组里的对象)，因为在 array 数组[0]到[I]间有 I 个对象。</span></span><br><span class="line"><span class="comment">// 派生类的长度通常都比基类要长。没有人知道如果用 BalancedBST 数组</span></span><br><span class="line"><span class="comment">// 来执行 printBSTArray 函数将会发生什么样的后果。</span></span><br></pre></td></tr></table></figure>
<h4 id="Item-M4：避免无用的缺省构造函数"><a href="#Item-M4：避免无用的缺省构造函数" class="headerlink" title="Item M4：避免无用的缺省构造函数"></a>Item M4：避免无用的缺省构造函数</h4><p>如果某个类实在没有办法去做默认构造函数，需要用下面的方法来解开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EquipmentPiece</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">EquipmentPiece</span>(<span class="type">int</span> IDNumber); </span><br><span class="line"> ... </span><br><span class="line">&#125;;</span><br><span class="line">EquipmentPiece bestPieces[<span class="number">10</span>]; <span class="comment">// 错误！没有正确调用 </span></span><br><span class="line">EquipmentPiece bestPieces[] = &#123; <span class="comment">// 正确, 提供了构造 </span></span><br><span class="line"> <span class="built_in">EquipmentPiece</span>(ID1), <span class="comment">// 函数的参数 </span></span><br><span class="line"> <span class="built_in">EquipmentPiece</span>(ID2), </span><br><span class="line"> <span class="built_in">EquipmentPiece</span>(ID3), </span><br><span class="line"> ..., </span><br><span class="line"> <span class="built_in">EquipmentPiece</span>(ID10) </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> EquipmentPiece* PEP; <span class="comment">// PEP 指针指向 </span></span><br><span class="line"> </span><br><span class="line">PEP bestPieces[<span class="number">10</span>]; <span class="comment">// 正确, 没有调用构造函数 </span></span><br><span class="line">PEP *bestPieces = <span class="keyword">new</span> PEP[<span class="number">10</span>]; <span class="comment">// 也正确 </span></span><br><span class="line">在指针数组里的每一个指针被重新赋值，以指向一个不同的 EquipmentPiece 对象： </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line"> bestPieces[i] = <span class="keyword">new</span> <span class="built_in">EquipmentPiece</span>( ID Number ); </span><br><span class="line"><span class="comment">// 为大小为 10 的数组 分配足够的内存 </span></span><br><span class="line"><span class="comment">// EquipmentPiece 对象; 详细情况请参见条款 M8 </span></span><br><span class="line"><span class="comment">// operator new[] 函数 </span></span><br><span class="line"><span class="type">void</span> *rawMemory = </span><br><span class="line"> <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="number">10</span>*<span class="built_in">sizeof</span>(EquipmentPiece)); </span><br><span class="line"><span class="comment">// make bestPieces point to it so it can be treated as an </span></span><br><span class="line"><span class="comment">// EquipmentPiece array </span></span><br><span class="line">EquipmentPiece *bestPieces = </span><br><span class="line"> <span class="built_in">static_cast</span>&lt;EquipmentPiece*&gt;(rawMemory); </span><br><span class="line"><span class="comment">// construct the EquipmentPiece objects in the memory </span></span><br><span class="line"><span class="comment">// 使用&quot;placement new&quot; (参见条款 M8) </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line"> <span class="keyword">new</span> (&amp;bestPieces[i]) <span class="built_in">EquipmentPiece</span>( ID Number ); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以与构造 bestPieces 对象相反的顺序 </span></span><br><span class="line"><span class="comment">// 解构它。 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line"> bestPieces[i].~<span class="built_in">EquipmentPiece</span>(); </span><br><span class="line"><span class="comment">// deallocate the raw memory </span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[](rawMemory); </span><br></pre></td></tr></table></figure>
<h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h3><h4 id="Item-M5：谨慎定义类型转换函数"><a href="#Item-M5：谨慎定义类型转换函数" class="headerlink" title="Item M5：谨慎定义类型转换函数"></a>Item M5：谨慎定义类型转换函数</h4><p>隐式类型转换运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> ... </span><br><span class="line"> <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// 转换 Rational 类成 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// r 的值是 1/2  </span></span><br><span class="line"><span class="type">double</span> d = <span class="number">0.5</span> * r; <span class="comment">// 转换 r 到 double,</span></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; </span><br><span class="line">cout &lt;&lt; r; <span class="comment">// 应该打印出&quot;1/2&quot; 但是编译器脑补成了操作符转换成double出来。</span></span><br></pre></td></tr></table></figure>
<p>构造函数用 explicit 声明，如果这样做，编译器会拒绝为了隐式类型转换而调用构造函数。</p>
<h4 id="Item-M6：自增-increment-、自减-decrement-操作符前缀形式与后缀形式的区别"><a href="#Item-M6：自增-increment-、自减-decrement-操作符前缀形式与后缀形式的区别" class="headerlink" title="Item M6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别"></a>Item M6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别</h4><p>80年代的时候，没有区分++/—的前缀、后缀两种的差别。后面90年代的时候才引入了这两种写法。</p>
<p>前缀形式有时叫做“增加然后取回”，后缀形式叫做“取回然后增加”。</p>
<p>为啥后缀方式需要返回const，其实就是先将老位置的值存储一份，然后再去调整当前值的位置。</p>
<p>如果对于性能有一些敏感，可以考虑使用前缀加法，这样的函数没有临时变量缓存。</p>
<p>可以回答一下为啥vector，map里面的迭代器++方法能返回内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPInt</span> &#123; <span class="comment">// &quot;unlimited precision int&quot; </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> UPInt&amp; <span class="keyword">operator</span>++(); <span class="comment">// ++ 前缀 </span></span><br><span class="line"> <span class="type">const</span> UPInt <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">// ++ 后缀 </span></span><br><span class="line"> UPInt&amp; <span class="keyword">operator</span>--(); <span class="comment">// -- 前缀 </span></span><br><span class="line"> <span class="type">const</span> UPInt <span class="keyword">operator</span>--(<span class="type">int</span>); <span class="comment">// -- 后缀 </span></span><br><span class="line"> UPInt&amp; <span class="keyword">operator</span>+=(<span class="type">int</span>); <span class="comment">// += 操作符，UPInts </span></span><br><span class="line"> <span class="comment">// 与 ints 相运算 </span></span><br><span class="line"> ... </span><br><span class="line">&#125;; </span><br><span class="line">UPInt i; </span><br><span class="line">++i; <span class="comment">// 调用 i.operator++(); </span></span><br><span class="line">i++; <span class="comment">// 调用 i.operator++(0);</span></span><br><span class="line">--i; <span class="comment">// 调用 i.operator--(); </span></span><br><span class="line">i--; <span class="comment">// 调用 i.operator--(0);</span></span><br><span class="line"><span class="comment">// 前缀形式：增加然后取回值 </span></span><br><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++() </span><br><span class="line">&#123; </span><br><span class="line"> *<span class="keyword">this</span> += <span class="number">1</span>; <span class="comment">// 增加 </span></span><br><span class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 取回值 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// postfix form: fetch and increment </span></span><br><span class="line"><span class="type">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="type">int</span>) </span><br><span class="line">&#123; </span><br><span class="line"> UPInt oldValue = *<span class="keyword">this</span>; <span class="comment">// 取回值 </span></span><br><span class="line"> ++(*<span class="keyword">this</span>); <span class="comment">// 增加 </span></span><br><span class="line"><span class="keyword">return</span> oldValue; <span class="comment">// 返回被取回的值 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="Item-M7：不要重载“-amp-amp-”-“-”-或“-”"><a href="#Item-M7：不要重载“-amp-amp-”-“-”-或“-”" class="headerlink" title="Item M7：不要重载“&amp;&amp;”,“||”, 或“,”"></a>Item M7：不要重载“&amp;&amp;”,“||”, 或“,”</h4><p>基础知识：（短路求值法）布尔变量在if语句里面如果是&amp;&amp;条件，将会按照顺序如果失败就回暂停。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span> ((index &lt; lowerBound) || (index &gt; upperBound)) ... </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这种思维被反复的灌输给程序员，所以我们要避免这种惯性的思维给大家带来麻烦。举个例子下面是重载操作符的代码真实运行的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression1 &amp;&amp; expression2) ... </span><br><span class="line"> 对于编译器来说，等同于下面代码之一： </span><br><span class="line"><span class="keyword">if</span> (expression1.<span class="keyword">operator</span>&amp;&amp;(expression2)) ... </span><br><span class="line"> <span class="comment">// when operator&amp;&amp; is a </span></span><br><span class="line"> <span class="comment">// member function </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">operator</span>&amp;&amp;(expression1, expression2)) ... </span><br><span class="line"> <span class="comment">// when operator&amp;&amp; is a </span></span><br><span class="line"> <span class="comment">// global function </span></span><br><span class="line"> <span class="comment">//这好像没有什么不同，但是函数调用法与短路求值法是绝对不同的。</span></span><br><span class="line"> <span class="comment">//这种函数被用起来的时候，其实expression1已经失败了，但是</span></span><br><span class="line"> <span class="comment">//expression2还是会被执行。</span></span><br></pre></td></tr></table></figure>
<p>正如显示的，存在一些限制，你不能重载下面的操作符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. .* :: ?: </span><br><span class="line"><span class="keyword">new</span> <span class="keyword">delete</span> <span class="keyword">sizeof</span> <span class="keyword">typeid</span> </span><br><span class="line">bbs.theithome.com</span><br><span class="line"><span class="keyword">static_cast</span> <span class="keyword">dynamic_cast</span> <span class="keyword">const_cast</span> <span class="keyword">reinterpret_cast</span> </span><br></pre></td></tr></table></figure>
<p>能重载的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> <span class="keyword">operator</span> <span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>[] <span class="keyword">operator</span> <span class="keyword">delete</span>[]</span><br><span class="line">+ - * / % ^ &amp; | ~ </span><br><span class="line">! = &lt; &gt; += -= *= /= %= </span><br><span class="line">^= &amp;= |= &lt;&lt; &gt;&gt; &gt;&gt;= &lt;&lt;= == != </span><br><span class="line">&lt;= &gt;= &amp;&amp; || ++ -- , -&gt;* -&gt; </span><br><span class="line">() []</span><br></pre></td></tr></table></figure>
<h4 id="Item-M8：理解各种不同含义的new和delete"><a href="#Item-M8：理解各种不同含义的new和delete" class="headerlink" title="Item M8：理解各种不同含义的new和delete"></a>Item M8：理解各种不同含义的new和delete</h4><p>new操作符（new operator）和new操作（operator new）的区别。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Memory Management&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这种是new操作符，是类似于系统内置的sizeof，包含两个步骤：</p>
<ol>
<li>分配raw的内存块；</li>
<li>将内存块去调用构造函数初始化对象；</li>
</ol>
<p>我们能提供的new操作符只能工作在第一步。编写这个函数的意图也是为了接管分配的权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 返回一块原始内存块，size 表示这个对象需要多少空间。</span></span><br></pre></td></tr></table></figure>
<p>placement new</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Widget</span>(<span class="type">int</span> widgetSize); </span><br><span class="line"> ... </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="type">void</span> *buffer, </span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">int</span> widgetSize)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">new</span> (buffer) <span class="built_in">Widget</span>(widgetSize); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *location)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">return</span> location; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 内存由外部分配传入函数，函数将会调用构造函数将内存块变成对象指针返回回去。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-异常"><a href="#3-异常" class="headerlink" title="3. 异常"></a>3. 异常</h3><blockquote>
<p>C 程序员能够仅通过 setjmp 和 longjmp 来完成与异常处理相似的功能。但是当 longjmp在 C++中使用时，<strong>它存在一些缺陷</strong>，当它调整堆栈时不能对局部对象调用析构函数。（WQ 加注，VC＋＋能保证这一点，但不要依赖这一点。）而大多数 C＋＋程序员依赖于这些析构函数的调用，所以 setjmp 和 longjmp 不能够替换异常处理。如果你需要一个方法，能够通知不可被忽略的异常状态，并且搜索栈空间（searching the stack）以便找到异常处理代码时，你还得确保局部对象的析构函数必须被调用，这时你就需要使用 C++的异常处理。</p>
</blockquote>
<h4 id="Item-M9：使用析构函数防止资源泄漏"><a href="#Item-M9：使用析构函数防止资源泄漏" class="headerlink" title="Item M9：使用析构函数防止资源泄漏"></a>Item M9：使用析构函数防止资源泄漏</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">while</span> (dataSource) &#123; <span class="comment">// 还有数据时,继续循环 </span></span><br><span class="line"> ALA *pa = <span class="built_in">readALA</span>(dataSource); <span class="comment">//得到下一个动物 </span></span><br><span class="line"> pa-&gt;<span class="built_in">processAdoption</span>(); <span class="comment">//处理收容动物 </span></span><br><span class="line"> <span class="keyword">delete</span> pa; <span class="comment">//删除 readALA 返回的对象 </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAdoptions</span><span class="params">(istream&amp; dataSource)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">while</span> (dataSource) &#123; </span><br><span class="line">    ALA *pa = <span class="built_in">readALA</span>(dataSource); </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      pa-&gt;<span class="built_in">processAdoption</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有异常 </span></span><br><span class="line">      <span class="keyword">delete</span> pa; <span class="comment">// 避免内存泄漏 </span></span><br><span class="line">      <span class="comment">// 当异常抛出时 </span></span><br><span class="line">      <span class="keyword">throw</span>; <span class="comment">// 传送异常给调用者 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pa; <span class="comment">// 避免资源泄漏 </span></span><br><span class="line">  &#125; <span class="comment">// 当没有异常抛出时 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里就引入了<code>auto_ptr</code>类，如果一个指针和这块内存的生存周期有强的依赖关系，推荐使用这种方式来管理这种指针，可以处理很多出问题的情况。</p>
<h4 id="Item-M10：在构造函数中防止资源泄漏"><a href="#Item-M10：在构造函数中防止资源泄漏" class="headerlink" title="Item M10：在构造函数中防止资源泄漏"></a>Item M10：在构造函数中防止资源泄漏</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">testBookEntryClass</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> BookEntry *pb = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> pb = <span class="keyword">new</span> <span class="built_in">BookEntry</span>(<span class="string">&quot;Addison-Wesley Publishing Company&quot;</span>, </span><br><span class="line"> <span class="string">&quot;One Jacob Way, Reading, MA 01867&quot;</span>); <span class="comment">// 可能在构造BookEntry的过程中，已经在分配了部分内存出现了异常，</span></span><br><span class="line"> <span class="comment">//所以需要在下层做一些更安全的的保护。</span></span><br><span class="line"> ... </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有异常 </span></span><br><span class="line"> <span class="keyword">delete</span> pb; <span class="comment">// 删除 pb,当抛出异常时 </span></span><br><span class="line"> <span class="keyword">throw</span>; <span class="comment">// 传递异常给调用者 </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">delete</span> pb; <span class="comment">// 正常删除 pb </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookEntry</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> ... <span class="comment">// 同上 </span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> ... </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span></span>; <span class="comment">// 通用清除代码 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BookEntry::cleanup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">delete</span> theImage; <span class="comment">// 这些事情在析构函数中也需要再做一次</span></span><br><span class="line"> <span class="keyword">delete</span> theAudioClip; </span><br><span class="line">&#125; </span><br><span class="line">BookEntry::<span class="built_in">BookEntry</span>(<span class="type">const</span> string&amp; name, </span><br><span class="line"> <span class="type">const</span> string&amp; address, </span><br><span class="line"> <span class="type">const</span> string&amp; imageFileName, </span><br><span class="line"> <span class="type">const</span> string&amp; audioClipFileName) </span><br><span class="line">: <span class="built_in">theName</span>(name), <span class="built_in">theAddress</span>(address), </span><br><span class="line"> <span class="built_in">theImage</span>(<span class="number">0</span>), <span class="built_in">theAudioClip</span>(<span class="number">0</span>) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 这 try block 是新加入的 </span></span><br><span class="line"> <span class="keyword">if</span> (imageFileName != <span class="string">&quot;&quot;</span>) &#123; </span><br><span class="line"> theImage = <span class="keyword">new</span> <span class="built_in">Image</span>(imageFileName); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (audioClipFileName != <span class="string">&quot;&quot;</span>) &#123; </span><br><span class="line"> theAudioClip = <span class="keyword">new</span> <span class="built_in">AudioClip</span>(audioClipFileName); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">catch</span> (...) &#123; <span class="comment">// 捕获所有异常 </span></span><br><span class="line"> <span class="keyword">delete</span> theImage; <span class="comment">// 完成必要的清除代码 </span></span><br><span class="line"> <span class="keyword">delete</span> theAudioClip; </span><br><span class="line"> <span class="keyword">throw</span>; <span class="comment">// 继续传递异常 </span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者再次推荐此处应该使用<code>auto_ptr</code>来管理这些指针，此书1996年，当时的C++专家就开始谈论exception带来的一系列问题，并且推荐智能指针的使用，避免程序出现各种问题。</p>
<h4 id="Item-M11：禁止异常信息（exceptions）传递到析构函数外"><a href="#Item-M11：禁止异常信息（exceptions）传递到析构函数外" class="headerlink" title="Item M11：禁止异常信息（exceptions）传递到析构函数外"></a>Item M11：禁止异常信息（exceptions）传递到析构函数外</h4><p>此条目和《Effective C++ Item 8 别让异常逃离析构函数》有相同的意思。</p>
<p>我们知道禁止异常传递到析构函数外有两个原因：</p>
<p>第一能够在异常转递的堆栈辗转开解（stack-unwinding）的过程中，防止 terminate 被调用。</p>
<p>调用析构函数时异常可能处于激活状态也可能没有处于激活状态。遗憾的是没有办法在析构函数内部区分出这两种情况。因此在写析构函数时你必须保守地假设有异常被激活。因为如果在一个异常被激活的同时，析构函数也抛出异常，并导致程序控制权转移到析构函数外，C++将调用 terminate 函数。</p>
<p>第二它能帮助确保析构函数总能完成我们希望它做的所有事情。（如果你仍旧不很信服我所说的理由，可以去看Herb Sutter 的文章 Exception-Safe Generic Containers ，特别是“Destructors That Throw and Why They’re Evil”这段）。</p>
<h4 id="Item-M12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异"><a href="#Item-M12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异" class="headerlink" title="Item M12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异"></a>Item M12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异</h4><p>传递函数参数时可以通过：传值、传递引用和传递指针。当使用抛异常，到捕获异常的时候也能使用这三种方式来定义。区别在于函数调用还会回去，异常、捕获是不会返回回去（因为异常之后的代码端其实都已经不会执行了，这段代码的scope完），所以无论你是否使用了引用方式，其实都做了一次构造。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种方式会有两次分配</span></span><br><span class="line"><span class="built_in">catch</span> (Widget w)</span><br><span class="line"><span class="comment">// 一次分配</span></span><br><span class="line"><span class="built_in">catch</span> (Widget&amp; w)</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> Widget&amp; w)</span><br></pre></td></tr></table></figure>
<p>如果子类抛出异常的时，转换成父类抛出，将会去掉子类的特性。父类能catch子类的throw。如果父类已经在前面catch了，在下面写子类的catch将永远不会执行。应该将子类的catch写到父类的前面。</p>
<h4 id="Item-M13：通过引用（reference）捕获异常"><a href="#Item-M13：通过引用（reference）捕获异常" class="headerlink" title="Item M13：通过引用（reference）捕获异常"></a>Item M13：通过引用（reference）捕获异常</h4><p>如果你通过引用捕获异常（catch by reference），你就能避开上述所有问题，不会为是否删除异常对象而烦恼；能够避开 slicing 异常对象；能够捕获标准异常类型；减少异常对象需要被拷贝的数目。所以你还在等什么？通过引用捕获异常吧（Catch exceptions by reference）！</p>
<p>如果需要使用 exception* ex方式，需要使用static exception。变量就没有释放。</p>
<p>也可以自己本地去 new 一个exception，catch之后用完之后自己去做delete。</p>
<p>还不如直接构造一个对象抛出，catch的时候使用 exception&amp; ex方式。</p>
<h4 id="Item-M14：审慎使用异常规格-exception-specifications"><a href="#Item-M14：审慎使用异常规格-exception-specifications" class="headerlink" title="Item M14：审慎使用异常规格(exception specifications)"></a>Item M14：审慎使用异常规格(exception specifications)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以抛出任意异常</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// a poorly designed template wrt exception specifications </span></span><br><span class="line"><span class="comment">// 不允许此处抛出异常。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> T&amp; lhs, <span class="type">const</span> T&amp; rhs) <span class="built_in">throw</span>() </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> &amp;lhs == &amp;rhs; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在C++11中如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用std::terminate()函数来终止程序的运行</p>
<p>可以通过在定义函数的时候，限定其无法抛出异常。这样注册函数指针的时候就会出现编译报错。</p>
<p>这种对于是否能抛出异常，抛出什么样的异常的定义就叫做“异常规格”检查。</p>
<p>如果代码中存在operator new和operator new[]就有可能出现bad_alloc错误。所以有new的函数调用，就要做bad_alloc的准备。</p>
<p>防范于未然才是比较好的。unexpected异常被抛出的时候，程序就有可能直接被终止。所以需要自己平时就管理好这些异常。</p>
<p>我们可以通过自定义一个类来替换掉系统默认的unexpected函数。通过<code>set_unexpected</code>函数来指定。这样就能防止程序被终止。</p>
<p>还有一种方法就是通过对有危险的函数做try catch(…)将全部的异常可能性都catch，防止出现问题。</p>
<h4 id="Item-M15：了解异常处理的系统开销"><a href="#Item-M15：了解异常处理的系统开销" class="headerlink" title="Item M15：了解异常处理的系统开销"></a>Item M15：了解异常处理的系统开销</h4><p>默认的情况下，异常处理是被开启的，如果全部的C+++代码都是自己实现，而且没有涉及到任何的异常抛出的情况。这样可以开启不支持异常处理的方式进行编译，这样可以减少程序的尺寸和提高速度。但是现在C++库很少不支持异常，只要还有一个库还支持，那就需要开启。</p>
<p>异常处理开销来源于try模块。程序的尺寸和运行速度会增加5%~10%。如果抛出异常的情况下，可能消耗会更加大。大多数情况下都不会抛出异常。当抛出异常从函数力返回可能会慢三个数量级。</p>
<p>为了使你的异常开销变小：尽量采用不支持异常的方式来编译程序；将try块代码压缩成不需要得使用的区间；使用异常规格限定你需要使用的地方，只有在需要异常的时候才会抛出。</p>
<h3 id="4-效率"><a href="#4-效率" class="headerlink" title="4. 效率"></a>4. 效率</h3><p>糟糕的设计和马虎的编程将会造成程序大小太大，运行需要更多内存，更多时间。</p>
<p>高效的程序首先是算法要比较过硬。如果太烂的实现可以比喻成一个二流的观光地。</p>
<p>阐述效率问题。</p>
<p>第一是从语言独立的角度，关注那些任何语言里面都能使用的东西。其实就是通用算法数据结构的基础要做的很好。</p>
<p>第二是关注C++语言本身。思路没有问题之后，需要用C++更好的表达你的思路。例如：平凡的构造和释放大量的对象。</p>
<h4 id="Item-M16：牢记-80－20-准则（80－20-rule）"><a href="#Item-M16：牢记-80－20-准则（80－20-rule）" class="headerlink" title="Item M16：牢记 80－20 准则（80－20 rule）"></a>Item M16：牢记 80－20 准则（80－20 rule）</h4><p>80-20准则说的就是20%的代码使用了80%的资源。</p>
<p>发现程序里面的消耗问题，不能只靠直觉、经验、算命纸牌等荒唐的东西。最好的方式是使用profiler告诉你程序的各个部分都消耗了多少时间。</p>
<h4 id="Item-M17：考虑使用lazy-evaluation（懒惰计算法）"><a href="#Item-M17：考虑使用lazy-evaluation（懒惰计算法）" class="headerlink" title="Item M17：考虑使用lazy evaluation（懒惰计算法）"></a>Item M17：考虑使用lazy evaluation（懒惰计算法）</h4><p>这个优化思路是能应用在其他的语言。</p>
<blockquote>
<p>引用计数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;&#125;;</span><br><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2 = s1; <span class="comment">// 拷贝构造函数。</span></span><br></pre></td></tr></table></figure>
<p>除非你确实需要，不去为任何东西制作拷贝。</p>
<blockquote>
<p>区别对待读取和写入</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Homer&#x27;s Iliad&quot;</span>; <span class="comment">// 假设是一个</span></span><br><span class="line">cout &lt;&lt; s[<span class="number">3</span>]; <span class="comment">// 调用 operator[] 读取 s[3] </span></span><br><span class="line">s[<span class="number">3</span>] = <span class="string">&#x27;x&#x27;</span>; <span class="comment">// 调用 operator[] 写入 s[3]</span></span><br></pre></td></tr></table></figure>
<p>我们应能够区别对待读调用和写调用，因为读取 reference-counted string 是很容<br>易的，而写入这个 string 则需要在写入前对该 string 值制作一个新拷贝。</p>
<blockquote>
<p>Lazy Fetching（懒惰提取）</p>
</blockquote>
<p>一个很大的对象，从数据库中加载起来。应该是先创建一个大对象壳子，然后在使用的时候再去将其内存初始化。这些成员变量使用mutable来修饰。这样在任何函数（包含const）里面都能去修改这个成员变量。</p>
<p>也可以通过const_cast，去除const成员函数中的this的const修饰。然后完成对于成员变量的修改。</p>
<blockquote>
<p>Lazy Expression Evaluation(懒惰表达式计算)</p>
</blockquote>
<p>举例子，两个100*100矩阵，如果需要计算乘法，如果一次性将期内存分配出来，并且计算出来，肯定会非常卡。当用的时候，我们再开始去计算其的值。APL—-1960发展起来的语言，能够进行矩阵的交互式计算。当时计算机的能力没有现在的微波炉芯片高，它能胜任矩阵的加、乘，甚至能够快速的与大矩阵相除。其实就是尽量推迟计算的时机。</p>
<p><code>Lazy evaluation</code> 懒惰的策略；</p>
<p><code>eager evaluation</code> 热情的策略；</p>
<p>总结：</p>
<ol>
<li>减少无用的拷贝；</li>
<li>通过operator[]区分出读操作，降低消耗；</li>
<li>避免不需要的数据库读取操作；</li>
<li>避免不需要的数字操作；</li>
</ol>
<ul>
<li>避免自己瞎猜，最好还是通过profiler调查某个模块是不是太慢了，如果存在就开始改造。</li>
</ul>
<h4 id="Item-M18：分期摊还期望的计算"><a href="#Item-M18：分期摊还期望的计算" class="headerlink" title="Item M18：分期摊还期望的计算"></a>Item M18：分期摊还期望的计算</h4><p><code>over-eager evaluation</code>（过度热情计算法）。</p>
<p>有些时候需要让程序变得更加的积极。比如计算大量数据的平均值、最小值、最大值。在每个数字加入进来的时候才会变化。所以可以考虑在加入的时候将这个值计算出来，防止调取的时候，反复计算。  </p>
<p>最简单方法就是在这里增加一个<code>caching</code>层。</p>
<p>在使用map的迭代器的时候两种写法的差别。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*it).second;</span><br><span class="line">it-&gt;second;</span><br></pre></td></tr></table></figure>
<p>为了遵循STL规则，it是个对象，不是指针，所以不能保证-&gt;被正确应用到它上面。所以(*it).second虽然反隋，但是保证能运行。</p>
<h4 id="Item-M19：理解临时对象的来源"><a href="#Item-M19：理解临时对象的来源" class="headerlink" title="Item M19：理解临时对象的来源"></a>Item M19：理解临时对象的来源</h4><p>程序员聊天时候，说的存在一段时间的变量被称为临时变量，在c++里面被称为函数的局部变量。C++真正的临时变量是看不见的，且不在堆上分配（non-heap）的临时对象。</p>
<p>产生这种未命名的对象通常有两种情况：为了是函数成功调用而进行的隐式类型转换和函数返回值对象时。</p>
<p>传递的参数类型和函数参数表类型不匹配时，触发了隐式类型转换，将会直接触发构造生成匹配类型的对象。这种情况出现在值传递、常量引用传递的情况下，非常量引用传递就不会触发。</p>
<p>函数返回值如果写成了const Number operator+(const Number&amp; lhs, const Number&amp; rhs);这样也会有构造函数析构函数。</p>
<h4 id="Item-M20：协助完成返回值优化"><a href="#Item-M20：协助完成返回值优化" class="headerlink" title="Item M20：协助完成返回值优化"></a>Item M20：协助完成返回值优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一种不合理的避免返回对象的方法 </span></span><br><span class="line"><span class="type">const</span> Rational * <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, </span><br><span class="line"> <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"><span class="comment">// 另一种危险的方法 (和不正确的)方法，用来 </span></span><br><span class="line"><span class="comment">// 避免返回对象 </span></span><br><span class="line"><span class="type">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, </span><br><span class="line"> <span class="type">const</span> Rational&amp; rhs) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="function">Rational <span class="title">result</span><span class="params">(lhs.numerator() * rhs.numerator(), </span></span></span><br><span class="line"><span class="params"><span class="function"> lhs.denominator() * rhs.denominator())</span></span>; </span><br><span class="line"> <span class="keyword">return</span> result;<span class="comment">//WQ 加注 返回时，其指向的对象已经不存在了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一种不合理的避免返回对象的方法 </span></span><br><span class="line"><span class="type">const</span> Rational * <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, </span><br><span class="line"> <span class="type">const</span> Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the most efficient way to write a function returning </span></span><br><span class="line"><span class="comment">// an object </span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> Rational <span class="keyword">operator</span>*(<span class="type">const</span> Rational&amp; lhs, </span><br><span class="line"> <span class="type">const</span> Rational&amp; rhs) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), </span><br><span class="line"> lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在C++里面有一种技术叫做(RVO)<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27000013">什么时候应当依靠返回值优化（RVO）</a>。学习了C++11之后，有可能程序员会想使用std::move来将一个object变成一个右值传递回去。刚刚那篇文章分析了这样写的问题。反而不能使用std::Move来做，而是使用<code>RVO</code>反而会速度快很多。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement?lq=1">stackoverflow-对比move-RVO</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">return_vector</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tmp &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; &amp;&amp;rval_ref = <span class="built_in">return_vector</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第二种写法</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt;&amp;&amp; <span class="title">return_vector</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tmp &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; &amp;&amp;rval_ref = <span class="built_in">return_vector</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">return_vector</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tmp &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; &amp;&amp;rval_ref = <span class="built_in">return_vector</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种写法 最好的一种方式。</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">return_vector</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; tmp &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; rval_ref = <span class="built_in">return_vector</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Item-M21：通过重载避免隐式类型转换"><a href="#Item-M21：通过重载避免隐式类型转换" class="headerlink" title="Item M21：通过重载避免隐式类型转换"></a>Item M21：通过重载避免隐式类型转换</h4><p>有关为什么返回值是 const 的解释，参见 Effective C++ 条款 21。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">const</span> UPInt&amp; lhs, <span class="type">const</span> UPInt&amp; rhs);</span><br><span class="line">UPInt upi1, upi2;</span><br><span class="line">UPInt upi3 = upi1 + upi2; <span class="comment">// 还算好</span></span><br><span class="line">upi3 = upi1 + <span class="number">10</span>;<span class="comment">// 会产生临时对象</span></span><br><span class="line"><span class="comment">// 自己去实现这些函数吧</span></span><br><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">const</span> UPInt&amp; lhs, <span class="comment">// add UPInt </span></span><br><span class="line"> <span class="type">int</span> rhs); <span class="comment">// and int </span></span><br><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">int</span> lhs, <span class="comment">// add int and </span></span><br><span class="line"> <span class="type">const</span> UPInt&amp; rhs); <span class="comment">// UPInt</span></span><br><span class="line"><span class="type">const</span> UPInt <span class="keyword">operator</span>+(<span class="type">int</span> lhs, <span class="type">int</span> rhs); <span class="comment">// 错误!</span></span><br><span class="line"><span class="comment">// 在 C++中有一条规则是每一个重载的 operator 必须带有一个用户定义类型（user-defined type）的参数。</span></span><br></pre></td></tr></table></figure>
<p>不要过度优化，记住80-20原则，对一个东西的优化，需要拿的出来比较靠得住的依据。</p>
<h4 id="Item-M22：考虑用运算符的赋值形式（op-）取代其单独形式（op）"><a href="#Item-M22：考虑用运算符的赋值形式（op-）取代其单独形式（op）" class="headerlink" title="Item M22：考虑用运算符的赋值形式（op=）取代其单独形式（op）"></a>Item M22：考虑用运算符的赋值形式（op=）取代其单独形式（op）</h4><p>举例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大多数程序员认为如果他们能这样写代码： </span></span><br><span class="line">x = x + y; x = x - y; </span><br><span class="line"><span class="comment">// 那他们也能这样写： </span></span><br><span class="line">x += y; x -= y;</span><br></pre></td></tr></table></figure>
<p>其实对于c++来说是存在不同的操作符重载的。operator+、operator=和 operator+=之间没有任何关系。加法操作符和赋值操作符。+=只需要一次性操作就好了。可以考虑直接使用operator+=实现operator+，这里面构造一个临时的变量。</p>
<p>与效率上做出折衷选择。也就是说，客户端可以决定是这样编写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c, d, result; </span><br><span class="line">... </span><br><span class="line">result = a + b + c + d; <span class="comment">// 可能用了 3 个临时对象 </span></span><br><span class="line"> <span class="comment">// 每个 operator+ 调用使用 1 个 </span></span><br><span class="line">result = a; <span class="comment">//不用临时对象 </span></span><br><span class="line">result += b; <span class="comment">//不用临时对象 </span></span><br><span class="line">result += c; <span class="comment">//不用临时对象 </span></span><br><span class="line">result += d; <span class="comment">//不用临时对象</span></span><br></pre></td></tr></table></figure>
<h4 id="Item-M23：考虑变更程序库"><a href="#Item-M23：考虑变更程序库" class="headerlink" title="Item M23：考虑变更程序库"></a>Item M23：考虑变更程序库</h4><p>介绍了<code>iostream</code>和<code>stdio</code>程序库的差别。c++库能支持类型安全，而且能扩展。stdio库效率高，<strong>可能</strong>没有安全检测，产生的文件也小，执行速度快。可以通过编写benchmark来对比两个库的速度差异。不过还需要自己动脑筋模拟客户的操作来编写一个<code>benchmark</code>来真实测试一次消耗情况。</p>
<p>优势它仅仅快一些（大约 20％），有时则快很多（接近 200％），但是我从来没有遇到过一种 iostream 的实现和与其相对应的 stdio 的实现运行速度一样快。</p>
<h4 id="Item-M24：理解虚拟函数、多继承、虚基类和RTTI所需的代价"><a href="#Item-M24：理解虚拟函数、多继承、虚基类和RTTI所需的代价" class="headerlink" title="Item M24：理解虚拟函数、多继承、虚基类和RTTI所需的代价"></a>Item M24：理解虚拟函数、多继承、虚基类和RTTI所需的代价</h4><p>每种C++编译器都会实现语言中的特新，而且程序员都不用去关心其细节。虚函数和对象大小和成员函数执行效率有关系，这块知识点需要多掌握一些。</p>
<p>调用一个虚拟函数的时候，大多数编译器将会使用<code>virtual table</code>、<code>virtual table pointers</code>来实现。</p>
<p><code>virtual table</code>通常是函数指针数组（有些编译器是使用的链表来处理）。非虚函数将不会放入这个列表中。每个类只需要一个vtbl拷贝。</p>
<p>C2继承于C1，在C2中未实现的C1虚方法，将会在C2 virtual table里面保存一份C1中实现的虚方法；如果在C2重新定义了，将会直接使用C2的虚方法。</p>
<p><img src="/2022/07/29/C++-MoreEffectiveC++/Item.M.24.1.png" alt="Item.M.24.1"></p>
<p><img src="/2022/07/29/C++-MoreEffectiveC++/Item.M.24.2.png" alt="Item.M.24.2"></p>
<p>总结：虚方法其实在每个子类里的<code>virtual table</code>都会存储一份函数指针。</p>
<p>编译器实现存在两种路线：</p>
<ol>
<li>对于提供集成开发环境的厂商，为每个可能需要使用vtbl的object文件生成一个vtbl拷贝。linker程序去去重拷贝。</li>
<li>使用启发式算法决定哪个object文件应该包含vtbl。要在一个object文件中生成一个类的vtbl，要求该object文件包含该类的第一个非内联、非纯虚拟函数（non-inline non-pure virtual function）。</li>
</ol>
<p>如果你过分喜欢声明虚函数为内联函数（参见 Effective C++ 条款 33），可能会造成启发式算法失败，在大型系统里面会造成同一个类的成百上千的vtbl拷贝。要避免virtual 变成一个inline函数。</p>
<p>用图例来说明内存分配的样子。</p>
<p>含有虚拟函数的对象内存布局为：</p>
<p><img src="/2022/07/29/C++-MoreEffectiveC++/Item.M.24.3.png" alt="Item.M.24.3"></p>
<p>下面有个指向vptr的指针。</p>
<p>vtbl数据结构是按照Class来分配的，当实例化出来object之后，通过vptr将指针指向对应的vtbl里面。</p>
<p><img src="/2022/07/29/C++-MoreEffectiveC++/Item.M.24.4.png" alt="Item.M.24.4"></p>
<p>实际上调用虚函数的效率和调用函数指针一样。虚拟函数本身通常不是性能的瓶颈。</p>
<p>在多重继承的时候会在vptr里面，为每一个基类都分配了vptr。自己独立的生成过一个vtbl，而且为每个基类都生成了特殊的vtbl。因此每个对象，每个类的空间都要占的更多。</p>
<p>运行时类型识别（RTTI），有地方存储了一个type_info的对象，存储是放入了class的vtbl的最前面，而且vtbl这个数据结构，不是到处都在复制，而是一种公用的数据结构。所以这块的开销不会造成困扰。</p>
<p>下面这个表各是对虚函数、多继承、虚基类以及 RTTI 所需主要代价的总结：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Faature</th>
<th style="text-align:left">Increases Size of Objects</th>
<th style="text-align:left">Increases Per-Class Data</th>
<th style="text-align:left">Reduces Inlining</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Virtual Functions</td>
<td style="text-align:left">☑</td>
<td style="text-align:left">☑</td>
<td style="text-align:left">☑</td>
</tr>
<tr>
<td style="text-align:left">Multiple Inheritance</td>
<td style="text-align:left">☑</td>
<td style="text-align:left">☑</td>
<td style="text-align:left">❌</td>
</tr>
<tr>
<td style="text-align:left">Virtaul Base Classes</td>
<td style="text-align:left">Often</td>
<td style="text-align:left">Sometimes</td>
<td style="text-align:left">❌</td>
</tr>
<tr>
<td style="text-align:left">RTTI</td>
<td style="text-align:left">❌</td>
<td style="text-align:left">☑</td>
<td style="text-align:left">❌</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-技巧"><a href="#5-技巧" class="headerlink" title="5. 技巧"></a>5. 技巧</h3><p>本章主要是介绍一些编程的技巧。在日复一日的软件开发工作时，下面这些信息都将使你受益。</p>
<h4 id="Item-M25：将构造函数和非成员函数虚拟化"><a href="#Item-M25：将构造函数和非成员函数虚拟化" class="headerlink" title="Item M25：将构造函数和非成员函数虚拟化"></a>Item M25：将构造函数和非成员函数虚拟化</h4><p><img src="/2022/07/29/C++-MoreEffectiveC++/Item.M.25.1.png" alt="Item.M.25.1"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NLComponent</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">// declaration of virtual copy constructor </span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> NLComponent * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>: <span class="keyword">public</span> NLComponent &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> TextBlock * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// virtual copy </span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>); &#125; <span class="comment">// constructor</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>: <span class="keyword">public</span> NLComponent &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> Graphic * <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="comment">// virtual copy </span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>); &#125; <span class="comment">// constructor </span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; s)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsLetter</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs);</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> list&lt;NLComponent*&gt; components;</span><br><span class="line">&#125;;</span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>(<span class="type">const</span> NewsLetter&amp; rhs) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// 遍历整个 rhs 链表，使用每个元素的虚拟拷贝构造函数 </span></span><br><span class="line"> <span class="comment">// 把元素拷贝进这个对象的 component 链表。 </span></span><br><span class="line"> <span class="comment">// 有关下面代码如何运行的详细情况，请参见条款 M35. </span></span><br><span class="line"> <span class="keyword">for</span> (list&lt;NLComponent*&gt;::const_iterator it = </span><br><span class="line"> rhs.components.<span class="built_in">begin</span>(); </span><br><span class="line"> it != rhs.components.<span class="built_in">end</span>(); </span><br><span class="line"> ++it) &#123; </span><br><span class="line"> <span class="comment">// &quot;it&quot; 指向 rhs.components 的当前元素，调用元素的 clone 函数， </span></span><br><span class="line"> <span class="comment">// 得到该元素的一个拷贝，并把该拷贝放到 </span></span><br><span class="line"> <span class="comment">// 这个对象的 component 链表的尾端。 </span></span><br><span class="line"> components.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>()); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; s, <span class="type">const</span> NLComponent&amp; c) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> c.<span class="built_in">print</span>(s);<span class="comment">// 调用应该要调用的函数</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="Item-M26：限制某个类所能产生的对象数量"><a href="#Item-M26：限制某个类所能产生的对象数量" class="headerlink" title="Item M26：限制某个类所能产生的对象数量"></a>Item M26：限制某个类所能产生的对象数量</h4><p>可以使用<code>namespace</code>来将函数的作用域限制起来。</p>
<p>将构造函数设置成<code>private</code>防止外部多次构造，局限在自己的<code>friend function</code>里面构造。</p>
<p>在构造、析构函数里面加入计数器，防止其过多次的构造。</p>
<p>最终抽象了一个模板计数基类来处理这些重复代码。当出现了多次分配，将会抛出<code>TooManyObjects</code>异常。</p>
<h4 id="Item-M27：要求或禁止在堆中产生对象"><a href="#Item-M27：要求或禁止在堆中产生对象" class="headerlink" title="Item M27：要求或禁止在堆中产生对象"></a>Item M27：要求或禁止在堆中产生对象</h4><p>两种情形：</p>
<ol>
<li>嵌入式环境中，堆空间很珍贵，所以可能不允许在堆上申请任何的对象；</li>
<li>不允许在堆上申请任何对象，防止内存泄漏；</li>
</ol>
<p>不允许在堆里面申请对象；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UPNumber</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">UPNumber</span>();</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> ~<span class="built_in">UPNumber</span>(); <span class="comment">// 防止栈上分配</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种方法也禁止了继承和包容（包容其实就是在其他类里面直接定义对象），因为他们的构造、析构函数被设置成了private方式了。</p>
<p>将其设置成protected方式，就能兼容继承问题。</p>
<blockquote>
<p>判断一个对象是否在堆中</p>
</blockquote>
<p>文中尝试了通过修改代码来将一个对象是否为堆上分配做标记，operator new操作符来做手脚，其实时徒劳的。比如 new MyClass[20];此语句将会只有第一个元素调用过，当第二个元素调用的时候，将会抛出异常，因为全部的20个对象都是使用了相同的标记位，而分配只做了一次。</p>
<p>堆、栈空间分配示意图：</p>
<p><img src="/2022/07/29/C++-MoreEffectiveC++/Item.M.27.1.png" alt="Item.M.27.1"></p>
<p>可能会动一些脑子去定义一个stack上的变量取地址，然后对比，其实也是会存在问题的。因为我们需要考虑static变量的地址。</p>
<p>最终还是通过重载new operator函数，将全部分配的内存地址都保存起来，当需要判断的时候，只需要通过查找这个内存块的地址是不是在之前分配过就好了。</p>
<blockquote>
<p>禁止堆对象</p>
</blockquote>
<p>如何制作一个无法在堆上分配的对象，其实这个处理就是将operator new函数设置成private方式。</p>
<h4 id="Item-M28：智能（smart）指针"><a href="#Item-M28：智能（smart）指针" class="headerlink" title="Item M28：智能（smart）指针"></a>Item M28：智能（smart）指针</h4><p>智能指针实现了类似内建指针的功能。启用之后的好处：</p>
<ol>
<li>构造和析构。创建会默认设置成0，而且某些智能指针会负责自动删除掉指向对象，防止资源泄露。</li>
</ol>
<p>老版本的auto_ptr其实就是unqiue_ptr，如果赋值应该要考虑将所有权交换掉。</p>
<ol>
<li><p>拷贝和赋值。有些智能指针是拷贝所指的对象（deep copy），有些事拷贝指针，有些指针不允许赋值。</p>
</li>
<li><p>defrefrencing。</p>
</li>
</ol>
<h4 id="Item-M29：引用计数"><a href="#Item-M29：引用计数" class="headerlink" title="Item M29：引用计数"></a>Item M29：引用计数</h4><h3 id="6-杂项"><a href="#6-杂项" class="headerlink" title="6. 杂项"></a>6. 杂项</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/28/gitbook/" rel="prev" title="gitbook">
      <i class="fa fa-chevron-left"></i> gitbook
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/01/Zig%E5%85%A5%E9%97%A8/" rel="next" title="Zig入门">
      Zig入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E8%AF%BB"><span class="nav-number">1.1.</span> <span class="nav-text">导读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E8%AE%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">1. 基础议题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M1%EF%BC%9A-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">Item M1： 指针与引用的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M2%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8C-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.2.</span> <span class="nav-text">Item M2：尽量使用C++风格的类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M3%EF%BC%9A-%E4%B8%8D%E8%A6%81%E5%AF%B9%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81"><span class="nav-number">1.2.3.</span> <span class="nav-text">Item M3： 不要对数组使用多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M4%EF%BC%9A%E9%81%BF%E5%85%8D%E6%97%A0%E7%94%A8%E7%9A%84%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">Item M4：避免无用的缺省构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.</span> <span class="nav-text">2. 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M5%EF%BC%9A%E8%B0%A8%E6%85%8E%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">Item M5：谨慎定义类型转换函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M6%EF%BC%9A%E8%87%AA%E5%A2%9E-increment-%E3%80%81%E8%87%AA%E5%87%8F-decrement-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%89%8D%E7%BC%80%E5%BD%A2%E5%BC%8F%E4%B8%8E%E5%90%8E%E7%BC%80%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.2.</span> <span class="nav-text">Item M6：自增(increment)、自减(decrement)操作符前缀形式与后缀形式的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M7%EF%BC%9A%E4%B8%8D%E8%A6%81%E9%87%8D%E8%BD%BD%E2%80%9C-amp-amp-%E2%80%9D-%E2%80%9C-%E2%80%9D-%E6%88%96%E2%80%9C-%E2%80%9D"><span class="nav-number">1.3.3.</span> <span class="nav-text">Item M7：不要重载“&amp;&amp;”,“||”, 或“,”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M8%EF%BC%9A%E7%90%86%E8%A7%A3%E5%90%84%E7%A7%8D%E4%B8%8D%E5%90%8C%E5%90%AB%E4%B9%89%E7%9A%84new%E5%92%8Cdelete"><span class="nav-number">1.3.4.</span> <span class="nav-text">Item M8：理解各种不同含义的new和delete</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%BC%82%E5%B8%B8"><span class="nav-number">1.4.</span> <span class="nav-text">3. 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M9%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%98%B2%E6%AD%A2%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">Item M9：使用析构函数防止资源泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M10%EF%BC%9A%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E9%98%B2%E6%AD%A2%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">Item M10：在构造函数中防止资源泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M11%EF%BC%9A%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%EF%BC%88exceptions%EF%BC%89%E4%BC%A0%E9%80%92%E5%88%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%A4%96"><span class="nav-number">1.4.3.</span> <span class="nav-text">Item M11：禁止异常信息（exceptions）传递到析构函数外</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M12%EF%BC%9A%E7%90%86%E8%A7%A3%E2%80%9C%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E2%80%9D%E4%B8%8E%E2%80%9C%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E2%80%9D%E6%88%96%E2%80%9C%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E2%80%9D%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">1.4.4.</span> <span class="nav-text">Item M12：理解“抛出一个异常”与“传递一个参数”或“调用一个虚函数”间的差异</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M13%EF%BC%9A%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%EF%BC%88reference%EF%BC%89%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-number">1.4.5.</span> <span class="nav-text">Item M13：通过引用（reference）捕获异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M14%EF%BC%9A%E5%AE%A1%E6%85%8E%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E8%A7%84%E6%A0%BC-exception-specifications"><span class="nav-number">1.4.6.</span> <span class="nav-text">Item M14：审慎使用异常规格(exception specifications)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M15%EF%BC%9A%E4%BA%86%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80"><span class="nav-number">1.4.7.</span> <span class="nav-text">Item M15：了解异常处理的系统开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%95%88%E7%8E%87"><span class="nav-number">1.5.</span> <span class="nav-text">4. 效率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M16%EF%BC%9A%E7%89%A2%E8%AE%B0-80%EF%BC%8D20-%E5%87%86%E5%88%99%EF%BC%8880%EF%BC%8D20-rule%EF%BC%89"><span class="nav-number">1.5.1.</span> <span class="nav-text">Item M16：牢记 80－20 准则（80－20 rule）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M17%EF%BC%9A%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8lazy-evaluation%EF%BC%88%E6%87%92%E6%83%B0%E8%AE%A1%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">1.5.2.</span> <span class="nav-text">Item M17：考虑使用lazy evaluation（懒惰计算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M18%EF%BC%9A%E5%88%86%E6%9C%9F%E6%91%8A%E8%BF%98%E6%9C%9F%E6%9C%9B%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">1.5.3.</span> <span class="nav-text">Item M18：分期摊还期望的计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M19%EF%BC%9A%E7%90%86%E8%A7%A3%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="nav-number">1.5.4.</span> <span class="nav-text">Item M19：理解临时对象的来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M20%EF%BC%9A%E5%8D%8F%E5%8A%A9%E5%AE%8C%E6%88%90%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96"><span class="nav-number">1.5.5.</span> <span class="nav-text">Item M20：协助完成返回值优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M21%EF%BC%9A%E9%80%9A%E8%BF%87%E9%87%8D%E8%BD%BD%E9%81%BF%E5%85%8D%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.5.6.</span> <span class="nav-text">Item M21：通过重载避免隐式类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M22%EF%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F%EF%BC%88op-%EF%BC%89%E5%8F%96%E4%BB%A3%E5%85%B6%E5%8D%95%E7%8B%AC%E5%BD%A2%E5%BC%8F%EF%BC%88op%EF%BC%89"><span class="nav-number">1.5.7.</span> <span class="nav-text">Item M22：考虑用运算符的赋值形式（op&#x3D;）取代其单独形式（op）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M23%EF%BC%9A%E8%80%83%E8%99%91%E5%8F%98%E6%9B%B4%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="nav-number">1.5.8.</span> <span class="nav-text">Item M23：考虑变更程序库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M24%EF%BC%9A%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%87%BD%E6%95%B0%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%9F%BA%E7%B1%BB%E5%92%8CRTTI%E6%89%80%E9%9C%80%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="nav-number">1.5.9.</span> <span class="nav-text">Item M24：理解虚拟函数、多继承、虚基类和RTTI所需的代价</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%8A%80%E5%B7%A7"><span class="nav-number">1.6.</span> <span class="nav-text">5. 技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M25%EF%BC%9A%E5%B0%86%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="nav-number">1.6.1.</span> <span class="nav-text">Item M25：将构造函数和非成员函数虚拟化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M26%EF%BC%9A%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AA%E7%B1%BB%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">Item M26：限制某个类所能产生的对象数量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M27%EF%BC%9A%E8%A6%81%E6%B1%82%E6%88%96%E7%A6%81%E6%AD%A2%E5%9C%A8%E5%A0%86%E4%B8%AD%E4%BA%A7%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.3.</span> <span class="nav-text">Item M27：要求或禁止在堆中产生对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M28%EF%BC%9A%E6%99%BA%E8%83%BD%EF%BC%88smart%EF%BC%89%E6%8C%87%E9%92%88"><span class="nav-number">1.6.4.</span> <span class="nav-text">Item M28：智能（smart）指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item-M29%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">1.6.5.</span> <span class="nav-text">Item M29：引用计数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%9D%82%E9%A1%B9"><span class="nav-number">1.7.</span> <span class="nav-text">6. 杂项</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Abel Sean"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Abel Sean</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">136</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://blog.csdn.net/erlang_hell" title="http:&#x2F;&#x2F;blog.csdn.net&#x2F;erlang_hell" rel="noopener" target="_blank">我的csdn-blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://dengwenyi88.github.io/" title="https:&#x2F;&#x2F;dengwenyi88.github.io&#x2F;" rel="noopener" target="_blank">dwy-blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://unity3d.io/" title="https:&#x2F;&#x2F;unity3d.io" rel="noopener" target="_blank">蔡总-blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Abel Sean</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b08c5201a4a52badc863',
      clientSecret: 'dd2c48988eb499969198746dae8ec2c7ccbad00b',
      repo        : 'BlogComment',
      owner       : 'swordhell',
      admin       : ['swordhell'],
      id          : 'ec43964ab850e8ffdaf3dd565a1e6eb5',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
