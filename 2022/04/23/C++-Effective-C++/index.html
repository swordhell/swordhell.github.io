<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swordhell.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="简介c++基础书，回顾。做一做笔记。这本书被侯杰推荐，第三版版编写于2005年。类似的还有More Effective C++，Scott Meyers，1996年编写，Exceptional C++，Herb Sutter，1999年编写。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++Effective-C++">
<meta property="og:url" content="https://swordhell.github.io/2022/04/23/C++-Effective-C++/index.html">
<meta property="og:site_name" content="Abel&#39;Blog">
<meta property="og:description" content="简介c++基础书，回顾。做一做笔记。这本书被侯杰推荐，第三版版编写于2005年。类似的还有More Effective C++，Scott Meyers，1996年编写，Exceptional C++，Herb Sutter，1999年编写。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-22T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-07T01:46:42.058Z">
<meta property="article:author" content="Abel Sean">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://swordhell.github.io/2022/04/23/C++-Effective-C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++Effective-C++ | Abel'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Abel'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我干了什么?究竟拿了时间换了什么?</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swordhell.github.io/2022/04/23/C++-Effective-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Abel Sean">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Abel'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++Effective-C++
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-23 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-23T00:00:00+08:00">2022-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-07 09:46:42" itemprop="dateModified" datetime="2023-06-07T09:46:42+08:00">2023-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1-%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">1-基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1-%E5%9F%BA%E7%A1%80/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>c++基础书，回顾。做一做笔记。这本书被侯杰推荐，第三版版编写于2005年。类似的还有More Effective C++，Scott Meyers，1996年编写，Exceptional C++，Herb Sutter，1999年编写。</p>
<span id="more"></span>
<h3 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1.让自己习惯C++"></a>1.让自己习惯C++</h3><h4 id="条款1-视C-为一个语言联邦"><a href="#条款1-视C-为一个语言联邦" class="headerlink" title="条款1 视C++为一个语言联邦"></a>条款1 视C++为一个语言联邦</h4><ol>
<li>c++先是继承了c语言；</li>
<li>增加了面向对象的内容；</li>
<li>Template C++，模板元编程；</li>
<li>STL，包含容器、迭代器、算法、函数对象；</li>
</ol>
<h4 id="条款2-尽量以const-enum-inline代替define"><a href="#条款2-尽量以const-enum-inline代替define" class="headerlink" title="条款2 尽量以const,enum,inline代替define"></a>条款2 尽量以const,enum,inline代替define</h4><p>防止出现什么问题。</p>
<h4 id="条款3-尽可能使用const"><a href="#条款3-尽可能使用const" class="headerlink" title="条款3 尽可能使用const"></a>条款3 尽可能使用const</h4><p>const最首先适用于定义常量变量。比define优势在于有namespace。在编译的时候，会有多份存在。</p>
<p>使用模板函数、inline函数替换掉define的函数，避免传值时如果有累加操作造成问题。</p>
<p>Const用于变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Char greeting[]=”hello”;</span><br><span class="line">Char*p = greeting;</span><br><span class="line">Const <span class="type">char</span>*p = greeting;<span class="comment">// 修饰内存块不可修改</span></span><br><span class="line">Char*<span class="type">const</span> p = greeting;<span class="comment">// 修饰指针不可修改</span></span><br><span class="line">Const <span class="type">char</span>* <span class="type">const</span> p = greeting;<span class="comment">// 两者都不能修改</span></span><br></pre></td></tr></table></figure>
<p>在class里面的this指针就是个<code>T*const this</code>;</p>
<p>Const 成员函数，为了确定该成员函数可当作const T* 指针调用。1.表面此函数不会修改任何成员；2.提供const 对象调用函数。我们在编写operator函数的时候，实现是否含有const分别实现操作函数。</p>
<p>const成员函数行为流派有两种。</p>
<p>Bitwise constness：const成员函数不会修改对象内任何一个bit。</p>
<p>Logic constness：const成员函数里面，需要修改部分成员变量。需要使用mutable修饰释放掉non-static成员变量的bitwise constness束缚。</p>
<p>编写const函数的实现，使用const_cast包装成非const，使用static_cast将自己修改成const，这样就能避免代码重新编写。避免代码重复。</p>
<h4 id="条款4-去顶对象被使用前已先被初始化"><a href="#条款4-去顶对象被使用前已先被初始化" class="headerlink" title="条款4 去顶对象被使用前已先被初始化"></a>条款4 去顶对象被使用前已先被初始化</h4><p>对象的变量在使用的时候，一定做过一次赋值，防止半随机造成不可知的问题。</p>
<h3 id="2-构造-析构-赋值运算"><a href="#2-构造-析构-赋值运算" class="headerlink" title="2.构造/析构/赋值运算"></a>2.构造/析构/赋值运算</h3><h4 id="条款5-了解C-默默编写并调用哪些函数"><a href="#条款5-了解C-默默编写并调用哪些函数" class="headerlink" title="条款5 了解C++默默编写并调用哪些函数"></a>条款5 了解C++默默编写并调用哪些函数</h4><p>需要搞清楚构造函数、复制构造函数的运行逻辑。</p>
<h4 id="条款6-若不想使用编译期自动生成的函数，就该明确拒绝"><a href="#条款6-若不想使用编译期自动生成的函数，就该明确拒绝" class="headerlink" title="条款6 若不想使用编译期自动生成的函数，就该明确拒绝"></a>条款6 若不想使用编译期自动生成的函数，就该明确拒绝</h4><p>如果不需要使用默认的构造、析构、赋值函数，那就需要明确的将其设置成private，或者是私有成员函数。在新版本里面可以直接使用delete来将函数置空。</p>
<h4 id="条款7-为多态基类声明virtual析构函数"><a href="#条款7-为多态基类声明virtual析构函数" class="headerlink" title="条款7 为多态基类声明virtual析构函数"></a>条款7 为多态基类声明virtual析构函数</h4><p>std::string作为基类是错误的，由于std::string的析构函数不是个virtual方式的。</p>
<p>需要学会如何计算一个class的size。</p>
<p>如果存在继承的情况，在构造、析构函数里面不要调用虚方法。还未生成其调用关系，这样就会造成问题。</p>
<h4 id="条款8-别让异常逃离析构函数"><a href="#条款8-别让异常逃离析构函数" class="headerlink" title="条款8 别让异常逃离析构函数"></a>条款8 别让异常逃离析构函数</h4><p>析构函数不要出现异常，否则会存在内存泄漏。</p>
<h4 id="条款9-绝不再构造和析构过程中调用virtual函数"><a href="#条款9-绝不再构造和析构过程中调用virtual函数" class="headerlink" title="条款9 绝不再构造和析构过程中调用virtual函数"></a>条款9 绝不再构造和析构过程中调用virtual函数</h4><p>因为这样调用的时候，从不会下降至derived class。</p>
<h4 id="条款10-令operator-返回一个reference-to-this"><a href="#条款10-令operator-返回一个reference-to-this" class="headerlink" title="条款10 令operator=返回一个reference to *this"></a>条款10 令operator=返回一个reference to *this</h4><p>这种主要是为了在赋值连锁形式的时候，可以直接获取一个引用。此规则约定俗成。为了减少连锁操作的时候，重复分配。</p>
<h4 id="条款11-在operator-中处理“自我赋值”"><a href="#条款11-在operator-中处理“自我赋值”" class="headerlink" title="条款11 在operator=中处理“自我赋值”"></a>条款11 在operator=中处理“自我赋值”</h4><p>Opertator=操作符，一定要判断是否在自己赋值自己，而且需要返回*this，因为有可能赋值给你的那个值在做完操作之后马上就销毁了。</p>
<p>复制对象的时候，一定要将每个成员变量都复制了,包括它的基类的数据结构也需要考虑。</p>
<h4 id="条款12-复制对象时勿忘其每个成分"><a href="#条款12-复制对象时勿忘其每个成分" class="headerlink" title="条款12 复制对象时勿忘其每个成分"></a>条款12 复制对象时勿忘其每个成分</h4><p>复制对象相关函数一共两个：复制构造函数，赋值操作符函数。</p>
<p>当子类在实现复制工作都时候，可能父类的成员无法访问，这样也得驱动父类的复制流程。</p>
<h3 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3.资源管理"></a>3.资源管理</h3><h4 id="条款13-用对象管理资源"><a href="#条款13-用对象管理资源" class="headerlink" title="条款13 用对象管理资源"></a>条款13 用对象管理资源</h4><p>可以考虑使用std::auto_ptr只能指针来控制内存释放。利用RAII管理内存。</p>
<h4 id="条款14-在资源管理类中小心coping行为"><a href="#条款14-在资源管理类中小心coping行为" class="headerlink" title="条款14 在资源管理类中小心coping行为"></a>条款14 在资源管理类中小心coping行为</h4><p>RAII(Resource Acquisition Is Initialization)，资源取得时机便是初始化时机。</p>
<p>使用了Lock类构造，析构函数来控制临界区。如果定义了两个并且将已经生成的Lock赋值给另外一个Lock，当第二个Lock构造的时候，将会重新进入临界区，造成问题。</p>
<h4 id="条款15-在资源管理类中提供访问原始数据结构的接口"><a href="#条款15-在资源管理类中提供访问原始数据结构的接口" class="headerlink" title="条款15 在资源管理类中提供访问原始数据结构的接口"></a>条款15 在资源管理类中提供访问原始数据结构的接口</h4><p>在new/delete应该要匹配方式来调用。New [],delete []。</p>
<p>将new语句和产生std::auto_ptr写到一块，这样可以防止异常造成内存泄漏。老的写法，新的写法是直接调用std::make_shared_ptr，其实意图也一样。</p>
<h4 id="条款16-成对使用new和delete时要采取相同形式"><a href="#条款16-成对使用new和delete时要采取相同形式" class="headerlink" title="条款16 成对使用new和delete时要采取相同形式"></a>条款16 成对使用new和delete时要采取相同形式</h4><p><code>new</code>对应<code>delete</code>；<code>new[]</code>对应<code>delete[]</code>。</p>
<h4 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17 以独立语句将newed对象置入智能指针"></a>条款17 以独立语句将newed对象置入智能指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用非常干脆的方式将内存分配和构造智能指针操作绑定一块</span></span><br><span class="line"><span class="comment">// 防止在这期间出现了任何的异常，造成内存丢失；</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4.设计与声明"></a>4.设计与声明</h3><h4 id="条款18-让接口容易被正确使用，不易被误用"><a href="#条款18-让接口容易被正确使用，不易被误用" class="headerlink" title="条款18 让接口容易被正确使用，不易被误用"></a>条款18 让接口容易被正确使用，不易被误用</h4><p>设计接口的时候应该要定义明确，防止调用者造成一些误会。</p>
<h4 id="条款19-设计class犹如设计type"><a href="#条款19-设计class犹如设计type" class="headerlink" title="条款19 设计class犹如设计type"></a>条款19 设计class犹如设计type</h4><p>设计类的时候，需要考虑的事情：</p>
<ul>
<li>新type的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值有什么样的差别？</li>
<li>新的对象如果被passed by value，意味着什么？</li>
<li>什么是新type的“合法值”？</li>
<li>你的新type需要配合某个继承图系（inheritance graph）吗？</li>
<li>你的新type需要什么样的转换？</li>
<li>什么样的操作符和函数对此新type而言是合理的？</li>
<li>什么样的标准函数应该驳回？<a href="#条款6-若不想使用编译期自动生成的函数，就该明确拒绝">条款6-若不想使用编译期自动生成的函数，就该明确拒绝</a></li>
<li>谁该取用新type的成员？</li>
<li>什么是新type的“未申明接口”（undeclared interface）？<a href="###条款29">条款29</a></li>
<li>你的新type有多么一般化？有可能可以使用template来实现一类的type。</li>
<li>你真的需要一个新type吗？</li>
</ul>
<h4 id="条款20-宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20 宁以pass-by-reference-to-const替换pass-by-value"></a>条款20 宁以pass-by-reference-to-const替换pass-by-value</h4><p>这个特性是来自于c++继承了c的环境，都是传值。容易造成复制构造函数函数的调用，并且在传递完成之后将会调用析构。</p>
<p>如果使用pass-by-value，可能造成了切割问题（slicing problem），继承类传入基类的变量将会抹去全部的多态。</p>
<p>使用pass-by-value的情况是在使用迭代器、函数对象的时候，可能需要。</p>
<h4 id="条款21-必须返回对象时，别妄想返回reference"><a href="#条款21-必须返回对象时，别妄想返回reference" class="headerlink" title="条款21 必须返回对象时，别妄想返回reference"></a>条款21 必须返回对象时，别妄想返回reference</h4><p>如果直接使用栈上内存，其实离开作用域就会无效。如果使用new方式，最后无人释放。如果使用static变量模式，在多线程，或者同一个语句里面会存在冲突的问题。所以最好的方式还是通过构造一个将亡值返回回去就好了，也不要使用引用方式。</p>
<h4 id="条款22-将成员变量定义成private模式"><a href="#条款22-将成员变量定义成private模式" class="headerlink" title="条款22 将成员变量定义成private模式"></a>条款22 将成员变量定义成private模式</h4><p>使用接口控制访问权限。</p>
<p>Public和protected两种类型都不算太好的封装。 保不齐继承、外部会乱用这些东西。</p>
<h4 id="条款23-宁以non-member、non-friend替换member函数"><a href="#条款23-宁以non-member、non-friend替换member函数" class="headerlink" title="条款23 宁以non-member、non-friend替换member函数"></a>条款23 宁以non-member、non-friend替换member函数</h4><p>在类里面提供力度很细的函数来提供操作，而用no-member、no-friend方式替换成员函数组装成套的调用。最终我们使用一个namespace将这些no-member函数封装起来。</p>
<h4 id="条款24-若所有参数都需要转换，就需要写一个non-member函数"><a href="#条款24-若所有参数都需要转换，就需要写一个non-member函数" class="headerlink" title="条款24 若所有参数都需要转换，就需要写一个non-member函数"></a>条款24 若所有参数都需要转换，就需要写一个non-member函数</h4><p>举例子就是A类，实现了operator *的操作函数，但是无法实现a实例乘上一个自然数。解决的方法就是去实现一个全局函数，const A&amp; operator(const A&amp; r,const A&amp; l);而且不需要设置其为A的friend函数。</p>
<h4 id="条款25-考虑写出一个不抛异常的swap函数"><a href="#条款25-考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25 考虑写出一个不抛异常的swap函数"></a>条款25 考虑写出一个不抛异常的swap函数</h4><p>提供一份swap函数的实现，不能让这个过程中出现任何的异常造成各种问题。C++11里面提供了std::move方法，加上了右值引用将会很好的优化交换的速度，减少大量的内存分配。swap也需要避免其中抛出异常造成内存问题。</p>
<h3 id="5-实现"><a href="#5-实现" class="headerlink" title="5.实现"></a>5.实现</h3><h4 id="条款26-尽可能延后变量定义出现的时间"><a href="#条款26-尽可能延后变量定义出现的时间" class="headerlink" title="条款26 尽可能延后变量定义出现的时间"></a>条款26 尽可能延后变量定义出现的时间</h4><p>如果代码段没有用到这个变量，可以不事先定义。如果这个函数在执行过程中，一些函数没有使用就出异常了，这样还是支付了此类的构造成本。</p>
<p>两个方案比较：</p>
<ol>
<li>for循环外面定义一个对象，在循环里面只对这个变量修改然后用；</li>
<li>在内部使用构造、析构来写临时变量；</li>
</ol>
<p>第二种方式清晰，当for循环很小的时候推荐使用。</p>
<h4 id="条款27-尽量减少调用cast语句"><a href="#条款27-尽量减少调用cast语句" class="headerlink" title="条款27 尽量减少调用cast语句"></a>条款27 尽量减少调用cast语句</h4><p>Cast方式老风格，c语言风格。</p>
<p>(T)val;c语言风格</p>
<p>T(val);函数风格</p>
<p>二者基本上无区别。</p>
<p>现在新的方式有下列种类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Const_cast</span>&lt;T&gt;(v)消除<span class="type">const</span>特性；</span><br><span class="line"><span class="built_in">Dynamic_cast</span>&lt;T&gt;(v)从基类转向派生类的转换，唯一有消耗的一种cast。</span><br><span class="line"><span class="built_in">Reinterpret_cast</span>&lt;T&gt;(v)尝试做一次低级转换，和编译器有关系。</span><br><span class="line"><span class="built_in">Static_cast</span>&lt;T&gt;(v)强制隐形转换，能做上面除了<span class="keyword">const_cast</span>之外的全部操作。</span><br></pre></td></tr></table></figure>
<p>好处：</p>
<ol>
<li>使用新的写法，更加能让代码使用grep找出来。</li>
<li>专用的cast方式，能让编译器帮忙矫正一些问题。</li>
</ol>
<p>优良的代码很少使用cast语句的，这个功能又是不可或缺的。</p>
<h4 id="条款28-避免返回handles指向对象内部成分"><a href="#条款28-避免返回handles指向对象内部成分" class="headerlink" title="条款28 避免返回handles指向对象内部成分"></a>条款28 避免返回handles指向对象内部成分</h4><p>类里面的handler返回尽量使用const T&amp;方法返回出去，这样能维护其封装性。</p>
<h4 id="条款29-为“异常安全”而努力是值得的"><a href="#条款29-为“异常安全”而努力是值得的" class="headerlink" title="条款29 为“异常安全”而努力是值得的"></a>条款29 为“异常安全”而努力是值得的</h4><p>Strive for exception-safe code</p>
<p>讲述了一个例子，使用c风格的lock,unlock，中间有一次delete一次计数器累加，还有一次内存分配。这种代码存在的一些不好的点是可能在new的时候发生异常，如何防范呢？直接使用shared_ptr来管理内存分配，使用RAII方式来控制lock,unlock操作，将delete/new操作直接使用shared_ptr的reset方式来制作，将累加代码移到最后一行，这样能减少大部分问题。</p>
<p>强烈安全级别的时候，使用copy-and-swap，将需要修改的对象拷贝一份出来，当新的一份内存的操作完全执行成功了，再去做一次swap。</p>
<p>在新的标准里面存在noexcept的语法。但是在std里面会存在std::bad_alloc的异常放出来。</p>
<h4 id="条款30-透彻了解inline的里里外外"><a href="#条款30-透彻了解inline的里里外外" class="headerlink" title="条款30 透彻了解inline的里里外外"></a>条款30 透彻了解inline的里里外外</h4><p>inline函数其实就是将这些代码直接嵌入到调用者部分，“不含函数调用”的代码。</p>
<p>免除了调用函数的成本，为每个调用者将这块的机器码复制过去，在内存比较小的机器上，将会吃掉更多内存。将会让代码膨胀，导致换页行为。</p>
<p>不要将析构、构造函数使用inline方式。</p>
<p>不要在template函数里面使用inline方式。</p>
<h4 id="条款31-将文件间的编译依赖关系降至最低"><a href="#条款31-将文件间的编译依赖关系降至最低" class="headerlink" title="条款31 将文件间的编译依赖关系降至最低"></a>条款31 将文件间的编译依赖关系降至最低</h4><p>使用接口来依赖。</p>
<p>能用object references,object pointers就不要使用object。</p>
<p>多使用class声明、而非定义。为声明和定义分离两个文件出来。</p>
<h3 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6.继承与面向对象设计"></a>6.继承与面向对象设计</h3><p>c++继承有三种：public/protected/private。</p>
<h4 id="条款32-确定你的public继承塑模出is-a关系"><a href="#条款32-确定你的public继承塑模出is-a关系" class="headerlink" title="条款32 确定你的public继承塑模出is-a关系"></a>条款32 确定你的public继承塑模出is-a关系</h4><p>public继承是is-a方式的，每个特性都需要在子类里面使用。</p>
<h4 id="条款33-避免遮挡继承而来的名称"><a href="#条款33-避免遮挡继承而来的名称" class="headerlink" title="条款33 避免遮挡继承而来的名称"></a>条款33 避免遮挡继承而来的名称</h4><p>如果遮挡了，那就要使用forward方式取驱动调用。</p>
<h4 id="条款34-区分接口继承和继承实现"><a href="#条款34-区分接口继承和继承实现" class="headerlink" title="条款34 区分接口继承和继承实现"></a>条款34 区分接口继承和继承实现</h4><p>Pure virtual：一定要子类实现；<br>virtual：基类提供缺省实现；<br>No-virtual：直接使用基类的实现，最好不要自己实现，可以声明成protected方式。</p>
<h4 id="条款35-考虑使用virtual以外的其他选择"><a href="#条款35-考虑使用virtual以外的其他选择" class="headerlink" title="条款35 考虑使用virtual以外的其他选择"></a>条款35 考虑使用virtual以外的其他选择</h4><p>这种模式其实就是将处理流程在基类里面想清楚，然后固化流程，提供中间处理特例。使用函数指针来提供灵活性。</p>
<h4 id="条款36-绝不重新定义继承而来的no-virtual函数"><a href="#条款36-绝不重新定义继承而来的no-virtual函数" class="headerlink" title="条款36 绝不重新定义继承而来的no-virtual函数"></a>条款36 绝不重新定义继承而来的no-virtual函数</h4><p>这样的函数是静态绑定，当调用的时候，很容易就变得混乱。</p>
<h4 id="条款37-绝不重新定义继承而来的缺省参数值"><a href="#条款37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37 绝不重新定义继承而来的缺省参数值"></a>条款37 绝不重新定义继承而来的缺省参数值</h4><p>在基类pure virtual函数中定义过了函数的默认参数，子类函数里面不能再去定义默认参数，可能会存在混乱的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ShapeColor</span> &#123;Red, Green,Blue&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color=Red)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">(ShapeColor color=Green)</span> <span class="type">const</span></span>; <span class="comment">// * 这个就是问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape* pr = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">pr-&gt;<span class="built_in">draw</span>(); <span class="comment">// 将会是Red方式。</span></span><br></pre></td></tr></table></figure>
<h4 id="条款38-通过复合塑模出has-a或者“根据某物实现出”"><a href="#条款38-通过复合塑模出has-a或者“根据某物实现出”" class="headerlink" title="条款38 通过复合塑模出has-a或者“根据某物实现出”"></a>条款38 通过复合塑模出has-a或者“根据某物实现出”</h4><p>Is-implemented-in-terms-of。</p>
<h4 id="条款39-明智的使用private继承方式"><a href="#条款39-明智的使用private继承方式" class="headerlink" title="条款39 明智的使用private继承方式"></a>条款39 明智的使用private继承方式</h4><p>private继承了之后，基类的protected/public的接口都会成为private。</p>
<h4 id="条款40-明智的谨慎的使用多重继承"><a href="#条款40-明智的谨慎的使用多重继承" class="headerlink" title="条款40 明智的谨慎的使用多重继承"></a>条款40 明智的谨慎的使用多重继承</h4><p>多重继承空间会消耗的大，但是也有存在的必要，最常见的就是iostream的实现，由于读写的fd需要独立。</p>
<h3 id="7-模板"><a href="#7-模板" class="headerlink" title="7.模板"></a>7.模板</h3><p>通用性代码编写需要使用到模板，看完这章也不会让你成为模板专家。</p>
<h4 id="条款41-了解隐式接口和编译期多态"><a href="#条款41-了解隐式接口和编译期多态" class="headerlink" title="条款41 了解隐式接口和编译期多态"></a>条款41 了解隐式接口和编译期多态</h4><p>面向对象世界里面，显式接口-explicit interface，运行期多态-runtime polymorphism 解决问题。</p>
<p>在模板世界里面，上述的显式接口，运行时多态都还存在，隐式接口-implicit interface，编译器多态-compile-time polymorphism 也将会被重视起来。</p>
<h4 id="条款42-了解typename的双重意义"><a href="#条款42-了解typename的双重意义" class="headerlink" title="条款42 了解typename的双重意义"></a>条款42 了解typename的双重意义</h4><p>Template里面有两种class/typename。其实没有不同。</p>
<p>当我们在template内部使用一个类型的时候需要增加一个typename C::const_iterator。这样能避免有个静态成员变量时这个名字。Nested dependent name。</p>
<h4 id="条款43-学习处理模板化基类内的名称"><a href="#条款43-学习处理模板化基类内的名称" class="headerlink" title="条款43 学习处理模板化基类内的名称"></a>条款43 学习处理模板化基类内的名称</h4><p>模板函数里面直接调用导入来的类的一个方法，如果出现了某个类需要特例化的时候，就需要自己去指定实现一份。从template继承下来的类，调用的时候需要this-&gt;方式，或者明白写上base class资格修饰符来完成。</p>
<h4 id="条款44-将于参数无关的代码抽离templates"><a href="#条款44-将于参数无关的代码抽离templates" class="headerlink" title="条款44 将于参数无关的代码抽离templates"></a>条款44 将于参数无关的代码抽离templates</h4><p>模板将会造成代码膨胀code bloat。二进制带着重复的代码、数据。</p>
<h4 id="条款45-运用成员函数模板接受所有兼容类型"><a href="#条款45-运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45 运用成员函数模板接受所有兼容类型"></a>条款45 运用成员函数模板接受所有兼容类型</h4><p>其实就是在class上定义过一个template<class t>，在构造/成员函数上也可以增加template<class u>来做修饰。这样的好处是成员函数能自由的生成更多的适配的函数出来给目标代码调用。</class></class></p>
<h4 id="条款46-需要类型转换时请为模板定义非成员函数"><a href="#条款46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46 需要类型转换时请为模板定义非成员函数"></a>条款46 需要类型转换时请为模板定义非成员函数</h4><p>这个思路其实类似条款24，当一个class需要兼容其他类型对其做操作符运算，最好从类里面分离出来。可以直接在template里面写一个friend const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)函数出来。条款30里面提到的在头文件里面的函数都会成为inline。为了让这个函数消耗更加小，其实应该将这个函数做出一个doMultiply的函数，让inline函数调用。</p>
<h4 id="条款47-请使用traits-classes表现类型信息"><a href="#条款47-请使用traits-classes表现类型信息" class="headerlink" title="条款47 请使用traits classes表现类型信息"></a>条款47 请使用traits classes表现类型信息</h4><p>这一章节需要理解了条款42，里面将会使用到typedef typename IterT::iterator_category。Z最终达成使用了if (typeid(typename std::iterator_traits<IterT>::iterator_category) == xxxx)的语句的编写，其实是在编译期间去确定代码的流程。<br>如果我们需要对这个固定式的函数做一些特例化，就需要使用重载了，其实就是将模板中定制好类型这样来调用。Traits广泛用于标准程序库中，可以在阅读stl源码相关代码的时候获取知识。<br>总结traits classes使得 typeid 在编译期可用。可以使用template，特例化完成实现。<br>重载技术，能在编译期对类型执行if…else测试。</IterT></p>
<h4 id="条款48-认识template元编程"><a href="#条款48-认识template元编程" class="headerlink" title="条款48 认识template元编程"></a>条款48 认识template元编程</h4><p>Template metaprogram其实就是c++写成，执行于C++编译器内的程序。它的输出就是若干的c++源码。TMP源于1990s。而且这个功能是非常有用的。如果没有啥映像，说明你一定没有足够认真地思考它。</p>
<p>两个伟大的效力：</p>
<ol>
<li>让某些事情更更容易。</li>
<li>可以将工作从运行期移植到编译期。</li>
</ol>
<p>编译期就能检查出问题，编译时间变长，执行更高效，更小空间，运行期更小内存。</p>
<p>递归函数演示，将可以使用TMP在编译期就计算出结果。</p>
<p>用三个例子来说明TMP的用途。</p>
<ol>
<li>确保量度单位正确。早期错误侦测。</li>
<li>优化矩阵运算。条款21提到operator*必须返回新对象，而条款44导入了SquareMatrix class。如果有4个矩阵×操作。会产生4次临时性矩阵保存调用结果。使用TMP里面的expression templates，就能合并这个操作。减少内存，执行效率会提高很多。</li>
<li>可以生成客户定制的设计模式实现品。Strategy（条款35）,observer，Visitor都可以使用TMP来做实现。</li>
</ol>
<p>TMP不是主流，程序库开发员会是它的重要用户。</p>
<p>可能在其他的书籍里面能看到更多的信息。</p>
<h3 id="8-定制new与delete"><a href="#8-定制new与delete" class="headerlink" title="8.定制new与delete"></a>8.定制new与delete</h3><h4 id="条款49-了解new-handler的行为"><a href="#条款49-了解new-handler的行为" class="headerlink" title="条款49 了解new-handler的行为"></a>条款49 了解new-handler的行为</h4><p>new操作的时候，如果内存不足将会抛异常。之前是返回null。<a href="#条款51-编写new和delete时需固守常规">条款51编写new和delete时需固守常规</a></p>
<p>设计良好的new-handler函数必须做到下面的事情：</p>
<ul>
<li>让更多内存可被使用。启动分配大块内存，new-handler的时将释还给程序使用。</li>
<li>安装另一个new-handler。当本身的new-handler无法处理，我们又知道又另一个可以替换的，能替换掉new-handler。</li>
<li>卸载new-handler。将null指针传入，当分配时，会抛出异常。</li>
<li>抛出bad_allo。不要再operator new里面捕获异常，将问题抛到内存索求处接着处理。</li>
<li>不返回，</li>
</ul>
<p>1993年，C++要求operator new必须在无法分配内存时返回null，新一代operator new应该抛出bad_alloc异常，为了兼容提供了“分配失败便返回null”行为。这个形式成为“nothrow”形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw2 = <span class="built_in">new</span> (std::nothrow) Widget;</span><br></pre></td></tr></table></figure>
<h4 id="条款50-了解new和delete的合理替换时机"><a href="#条款50-了解new和delete的合理替换时机" class="headerlink" title="条款50 了解new和delete的合理替换时机"></a>条款50 了解new和delete的合理替换时机</h4><ul>
<li>用来检查运用上的错误。</li>
<li>为了强化效能。</li>
<li><p>为了收集使用上的统计数据。</p>
</li>
<li><p>为了检测运用错误。</p>
</li>
<li>为了收集动态内存值使用统计信息。</li>
<li>为了增加分配和归还的速度。</li>
<li>为了降低缺省管理器带来的空间额外开销。</li>
<li>为了弥补缺省分配其中的非最佳齐位</li>
<li>为了将相关对象成簇集中。</li>
<li>为了获取非传统的行为。</li>
<li>有许多里有需要写一个自定义的new和delete，包括改善效能、对heap运行错误进行调试、收集heap使用信息。</li>
</ul>
<h4 id="条款51-编写new和delete时需固守常规"><a href="#条款51-编写new和delete时需固守常规" class="headerlink" title="条款51 编写new和delete时需固守常规"></a>条款51 编写new和delete时需固守常规</h4><ul>
<li>需要检查是否在分配0byte的内存。</li>
<li>应该包含一个无限循环，并且尝试分配内存，如果无法满足就调用new-handler。class专属版本则还应该处理“比正确大小更大的申请”。子类size可能比基类大。</li>
<li>delete的时候，收到null的指针啥时候都不做。</li>
</ul>
<h4 id="条款52-写了placement-new也要写placement-delete"><a href="#条款52-写了placement-new也要写placement-delete" class="headerlink" title="条款52 写了placement new也要写placement delete"></a>条款52 写了placement new也要写placement delete</h4><ul>
<li>如果写了一个替换掉new，要写一个delete。否则会有可能内存泄漏。</li>
<li>写了替换的new,delete，不要无意识地掩盖了正常版本。</li>
</ul>
<h3 id="9-杂项"><a href="#9-杂项" class="headerlink" title="9.杂项"></a>9.杂项</h3><h4 id="条款53-不要轻忽编译器的警告"><a href="#条款53-不要轻忽编译器的警告" class="headerlink" title="条款53 不要轻忽编译器的警告"></a>条款53 不要轻忽编译器的警告</h4><ul>
<li>努力让自己的编译期最严苛警告级别。</li>
<li>不要过度依赖于编译期的报警，可能不同编译器警告不一样，所以有可能换了个编译器警告就没有了。</li>
</ul>
<h4 id="条款54-让自己熟悉包括TR1在内的标准程序库"><a href="#条款54-让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="条款54 让自己熟悉包括TR1在内的标准程序库"></a>条款54 让自己熟悉包括TR1在内的标准程序库</h4><p>TR1表示<code>Technical Report 1</code>。这里面的一些东西都已经加入到了c++11标准了。</p>
<ul>
<li>stack,priority_queue</li>
<li>国际化wchar_t</li>
<li>复数模板 complex valarray</li>
<li>shared_ptr weak_ptr。</li>
<li>function</li>
<li>bind语法</li>
<li>Hash tables</li>
<li>正则表达式</li>
<li>tuples 变量数组</li>
<li>array 固定长度的数组STL化</li>
<li>mem_fn 绑定成员函数</li>
<li>reference_wrapper 让references更像对象。</li>
<li>random_number 随机数</li>
<li>数学特殊函数。</li>
<li>C99兼容扩展</li>
<li>traits classes</li>
<li>result_of 推到函数调用的返回值。</li>
</ul>
<h4 id="条款55-让自己熟悉Boost库"><a href="#条款55-让自己熟悉Boost库" class="headerlink" title="条款55 让自己熟悉Boost库"></a>条款55 让自己熟悉Boost库</h4><ul>
<li>字符串与文本处理</li>
<li>容器：bitsets，多维数组</li>
<li>函数对象和高级编程，lambda表达式。</li>
<li>泛型编程，可见 条款47</li>
<li>模板元编程 条款48</li>
<li>数学和数值计算。有理数、八元数、四元数，公约数，多从运算、随机数。</li>
<li>正确性和测试，条款41.</li>
<li>数据结构，覆盖了TR1的类型。</li>
<li>支持C++和python无缝操作</li>
<li>内存，scoped_array，智能指针。</li>
<li>杂项 CRC检测、时间日期处理，文件系统。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/22/Qt/" rel="prev" title="Qt">
      <i class="fa fa-chevron-left"></i> Qt
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/24/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0/" rel="next" title="关于学习">
      关于学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC"><span class="nav-number">1.1.</span> <span class="nav-text">1.让自己习惯C++</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE1-%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="nav-number">1.1.1.</span> <span class="nav-text">条款1 视C++为一个语言联邦</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE2-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E4%BB%A3%E6%9B%BFdefine"><span class="nav-number">1.1.2.</span> <span class="nav-text">条款2 尽量以const,enum,inline代替define</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE3-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="nav-number">1.1.3.</span> <span class="nav-text">条款3 尽可能使用const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE4-%E5%8E%BB%E9%A1%B6%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.4.</span> <span class="nav-text">条款4 去顶对象被使用前已先被初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0-%E6%9E%90%E6%9E%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="nav-number">1.2.</span> <span class="nav-text">2.构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE5-%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">条款5 了解C++默默编写并调用哪些函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE6-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="nav-number">1.2.2.</span> <span class="nav-text">条款6 若不想使用编译期自动生成的函数，就该明确拒绝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE7-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">条款7 为多态基类声明virtual析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE8-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">条款8 别让异常逃离析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE9-%E7%BB%9D%E4%B8%8D%E5%86%8D%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.</span> <span class="nav-text">条款9 绝不再构造和析构过程中调用virtual函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE10-%E4%BB%A4operator-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-this"><span class="nav-number">1.2.6.</span> <span class="nav-text">条款10 令operator&#x3D;返回一个reference to *this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE11-%E5%9C%A8operator-%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D"><span class="nav-number">1.2.7.</span> <span class="nav-text">条款11 在operator&#x3D;中处理“自我赋值”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE12-%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%AA%E6%88%90%E5%88%86"><span class="nav-number">1.2.8.</span> <span class="nav-text">条款12 复制对象时勿忘其每个成分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">3.资源管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE13-%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="nav-number">1.3.1.</span> <span class="nav-text">条款13 用对象管理资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE14-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83coping%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.3.2.</span> <span class="nav-text">条款14 在资源管理类中小心coping行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE15-%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E8%AE%BF%E9%97%AE%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.3.</span> <span class="nav-text">条款15 在资源管理类中提供访问原始数据结构的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE16-%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="nav-number">1.3.4.</span> <span class="nav-text">条款16 成对使用new和delete时要采取相同形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">1.3.5.</span> <span class="nav-text">条款17 以独立语句将newed对象置入智能指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.</span> <span class="nav-text">4.设计与声明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE18-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">条款18 让接口容易被正确使用，不易被误用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE19-%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type"><span class="nav-number">1.4.2.</span> <span class="nav-text">条款19 设计class犹如设计type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE20-%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value"><span class="nav-number">1.4.3.</span> <span class="nav-text">条款20 宁以pass-by-reference-to-const替换pass-by-value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE21-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9Ereference"><span class="nav-number">1.4.4.</span> <span class="nav-text">条款21 必须返回对象时，别妄想返回reference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE22-%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E6%88%90private%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.5.</span> <span class="nav-text">条款22 将成员变量定义成private模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE23-%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.6.</span> <span class="nav-text">条款23 宁以non-member、non-friend替换member函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E9%83%BD%E9%9C%80%E8%A6%81%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%B0%B1%E9%9C%80%E8%A6%81%E5%86%99%E4%B8%80%E4%B8%AAnon-member%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.7.</span> <span class="nav-text">条款24 若所有参数都需要转换，就需要写一个non-member函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE25-%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.8.</span> <span class="nav-text">条款25 考虑写出一个不抛异常的swap函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.</span> <span class="nav-text">5.实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE26-%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%87%BA%E7%8E%B0%E7%9A%84%E6%97%B6%E9%97%B4"><span class="nav-number">1.5.1.</span> <span class="nav-text">条款26 尽可能延后变量定义出现的时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE27-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E8%B0%83%E7%94%A8cast%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.5.2.</span> <span class="nav-text">条款27 尽量减少调用cast语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE28-%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="nav-number">1.5.3.</span> <span class="nav-text">条款28 避免返回handles指向对象内部成分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE29-%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="nav-number">1.5.4.</span> <span class="nav-text">条款29 为“异常安全”而努力是值得的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE30-%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inline%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="nav-number">1.5.5.</span> <span class="nav-text">条款30 透彻了解inline的里里外外</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE31-%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="nav-number">1.5.6.</span> <span class="nav-text">条款31 将文件间的编译依赖关系降至最低</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.6.</span> <span class="nav-text">6.继承与面向对象设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE32-%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">条款32 确定你的public继承塑模出is-a关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8C%A1%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-number">1.6.2.</span> <span class="nav-text">条款33 避免遮挡继承而来的名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE34-%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.3.</span> <span class="nav-text">条款34 区分接口继承和继承实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE35-%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8virtual%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="nav-number">1.6.4.</span> <span class="nav-text">条款35 考虑使用virtual以外的其他选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE36-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84no-virtual%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.5.</span> <span class="nav-text">条款36 绝不重新定义继承而来的no-virtual函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE37-%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-number">1.6.6.</span> <span class="nav-text">条款37 绝不重新定义继承而来的缺省参数值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE38-%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E8%80%85%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="nav-number">1.6.7.</span> <span class="nav-text">条款38 通过复合塑模出has-a或者“根据某物实现出”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE39-%E6%98%8E%E6%99%BA%E7%9A%84%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-number">1.6.8.</span> <span class="nav-text">条款39 明智的使用private继承方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE40-%E6%98%8E%E6%99%BA%E7%9A%84%E8%B0%A8%E6%85%8E%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.9.</span> <span class="nav-text">条款40 明智的谨慎的使用多重继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.7.</span> <span class="nav-text">7.模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="nav-number">1.7.1.</span> <span class="nav-text">条款41 了解隐式接口和编译期多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE42-%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="nav-number">1.7.2.</span> <span class="nav-text">条款42 了解typename的双重意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE43-%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-number">1.7.3.</span> <span class="nav-text">条款43 学习处理模板化基类内的名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE44-%E5%B0%86%E4%BA%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplates"><span class="nav-number">1.7.4.</span> <span class="nav-text">条款44 将于参数无关的代码抽离templates</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE45-%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.5.</span> <span class="nav-text">条款45 运用成员函数模板接受所有兼容类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE46-%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.6.</span> <span class="nav-text">条款46 需要类型转换时请为模板定义非成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE47-%E8%AF%B7%E4%BD%BF%E7%94%A8traits-classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">1.7.7.</span> <span class="nav-text">条款47 请使用traits classes表现类型信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE48-%E8%AE%A4%E8%AF%86template%E5%85%83%E7%BC%96%E7%A8%8B"><span class="nav-number">1.7.8.</span> <span class="nav-text">条款48 认识template元编程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%AE%9A%E5%88%B6new%E4%B8%8Edelete"><span class="nav-number">1.8.</span> <span class="nav-text">8.定制new与delete</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE49-%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.8.1.</span> <span class="nav-text">条款49 了解new-handler的行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE50-%E4%BA%86%E8%A7%A3new%E5%92%8Cdelete%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA"><span class="nav-number">1.8.2.</span> <span class="nav-text">条款50 了解new和delete的合理替换时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE51-%E7%BC%96%E5%86%99new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84"><span class="nav-number">1.8.3.</span> <span class="nav-text">条款51 编写new和delete时需固守常规</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE52-%E5%86%99%E4%BA%86placement-new%E4%B9%9F%E8%A6%81%E5%86%99placement-delete"><span class="nav-number">1.8.4.</span> <span class="nav-text">条款52 写了placement new也要写placement delete</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%9D%82%E9%A1%B9"><span class="nav-number">1.9.</span> <span class="nav-text">9.杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE53-%E4%B8%8D%E8%A6%81%E8%BD%BB%E5%BF%BD%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="nav-number">1.9.1.</span> <span class="nav-text">条款53 不要轻忽编译器的警告</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE54-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%ACTR1%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93"><span class="nav-number">1.9.2.</span> <span class="nav-text">条款54 让自己熟悉包括TR1在内的标准程序库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE55-%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89Boost%E5%BA%93"><span class="nav-number">1.9.3.</span> <span class="nav-text">条款55 让自己熟悉Boost库</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Abel Sean"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Abel Sean</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://blog.csdn.net/erlang_hell" title="http:&#x2F;&#x2F;blog.csdn.net&#x2F;erlang_hell" rel="noopener" target="_blank">我的csdn-blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://dengwenyi88.github.io/" title="https:&#x2F;&#x2F;dengwenyi88.github.io&#x2F;" rel="noopener" target="_blank">dwy-blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://unity3d.io/" title="https:&#x2F;&#x2F;unity3d.io" rel="noopener" target="_blank">蔡总-blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Abel Sean</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b08c5201a4a52badc863',
      clientSecret: 'dd2c48988eb499969198746dae8ec2c7ccbad00b',
      repo        : 'BlogComment',
      owner       : 'swordhell',
      admin       : ['swordhell'],
      id          : 'b1bb98ae9f8abff43ce8d275295df1c7',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
